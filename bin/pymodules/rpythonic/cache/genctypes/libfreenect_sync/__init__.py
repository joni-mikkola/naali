## generated by RPythonic 0.3.6pre14
## http://code.google.com/p/rpythonic/
import os, sys, ctypes
IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)

## this ctypes file expects to be in the cache directory, 
## with precompiled c-libraries two directories up, if the library is not there try to load from the system.
_clibs_dir = os.path.join( os.path.dirname(os.path.abspath(__file__)), '../../clibs' )
_clibs_dir = os.path.abspath( _clibs_dir )

def _load_ctypes_lib( name ):
	if os.name == 'posix':
		if sys.platform=='linux2':
			name += '.so'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'linux32')
			else: 		path = os.path.join(_clibs_dir,'linux64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			elif os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			else: return ctypes.CDLL(name) #fallback

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):	# cheap trick, abuse **kw, and look for "pointer"
		if 'pointer' in kw: self._pointer = kw['pointer']
		elif kw: raise SyntaxError	# sorry, you can not init with keywords
		else: self._pointer = ctypes.pointer( self._ctypes_struct_(*args) )
	def __getattr__(self,name):
		if hasattr( self._pointer.contents, name ):
			return getattr( self._pointer.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					#func = method._rpythonic_function_
					#return lambda *args: func( self, *args )	# what!, not self._pointer ??
					func = parent._rpythonic_unbound_lookup_[ method ]
					n = func.name
					if len(func.argnames) > 1:
						argnames = func.argnames[ 1 : ]
						a = ',' + '=None,'.join( argnames ) + '=None'
						b = ','.join( argnames )
					else: a = b = ''
					lamb = eval( 'lambda self %s: %s( self._pointer, %s )' %(a,n,b) )
					setattr( self.__class__, name, lamb )
					#return lamb	# this would return the unbound lambda, must call getattr again
					return getattr( self, name )

			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self._pointer, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self._pointer, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		if type: return self._ctypes_struct_
		else: return self._pointer

PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert'.split()


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	for n1 in names:
		prefix = ''
		for i,char in enumerate(n1):
			prefix += char
			if prefix not in possibles:
				possibles[ prefix ] = 0
				for n2 in names:
					if n2.startswith( prefix ):
						possibles[ prefix ] += 1

				if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
					rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self._pointer, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass._ctypes_struct_ = struct
	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer defines it
					f.return_wrapper = klass._rpythonic_wrapper_class_

def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )

_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}

class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed
		self.argtypes = tuple( self.argtypes )
		self.argnames = tuple( self.argnames )
		self.argtypestypes = tuple( self.argtypestypes )
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		try:
			func = self.function = getattr(_ctypes_lib_, self.name )
			RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
		except:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )
		if self.function: self.reset()


	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg._pointer
			elif hasattr( arg, '_rpythonic_' ): arg = arg._pointer	# workaround

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					ptr = k( k._type_() )		# not k() otherwise null pointer error
					for j, char in enumerate(arg): ptr[ j ] = char.encode('ascii')
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else: ptr = arg	# buggy TODO
				#else:		# wrap py object - not safe!!
				#	ptr = ctypes.cast( ctypes.pointer(ctypes.py_object(arg)), k )
				cargs[ i ] = ptr
			elif kt is PyCFuncPtrType:
				cargs[ i ] = self.callbacks[ i ] = k( arg )		# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take argument pointer=...
		#print( cargs )
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg._pointer
			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )




_clib_name_ = 'libfreenect_sync'
print('loading lib', _clib_name_)
print( os.path.abspath( os.path.curdir ) )
_ctypes_lib_ = _load_ctypes_lib( _clib_name_ )
assert _ctypes_lib_
print( _ctypes_lib_._name )

## macro globals ##
## enums ##
_itimer_which = { 
	"ITIMER_REAL" : 0, 
	"ITIMER_VIRTUAL" : 1, 
	"ITIMER_PROF" : 2, 
}

libusb_iso_sync_type = { 
	"LIBUSB_ISO_SYNC_TYPE_NONE" : 0, 
	"LIBUSB_ISO_SYNC_TYPE_ASYNC" : 1, 
	"LIBUSB_ISO_SYNC_TYPE_ADAPTIVE" : 2, 
	"LIBUSB_ISO_SYNC_TYPE_SYNC" : 3, 
}

libusb_request_type = { 
	"LIBUSB_REQUEST_TYPE_STANDARD" : 0, 
	"LIBUSB_REQUEST_TYPE_CLASS" : 32, 
	"LIBUSB_REQUEST_TYPE_VENDOR" : 64, 
	"LIBUSB_REQUEST_TYPE_RESERVED" : 96, 
}

libusb_transfer_type = { 
	"LIBUSB_TRANSFER_TYPE_CONTROL" : 0, 
	"LIBUSB_TRANSFER_TYPE_ISOCHRONOUS" : 1, 
	"LIBUSB_TRANSFER_TYPE_BULK" : 2, 
	"LIBUSB_TRANSFER_TYPE_INTERRUPT" : 3, 
}

libusb_endpoint_direction = { 
	"LIBUSB_ENDPOINT_IN" : 128, 
	"LIBUSB_ENDPOINT_OUT" : 0, 
}

libusb_standard_request = { 
	"LIBUSB_REQUEST_GET_STATUS" : 0, 
	"LIBUSB_REQUEST_CLEAR_FEATURE" : 1, 
	"LIBUSB_REQUEST_SET_FEATURE" : 3, 
	"LIBUSB_REQUEST_SET_ADDRESS" : 5, 
	"LIBUSB_REQUEST_GET_DESCRIPTOR" : 6, 
	"LIBUSB_REQUEST_SET_DESCRIPTOR" : 7, 
	"LIBUSB_REQUEST_GET_CONFIGURATION" : 8, 
	"LIBUSB_REQUEST_SET_CONFIGURATION" : 9, 
	"LIBUSB_REQUEST_GET_INTERFACE" : 10, 
	"LIBUSB_REQUEST_SET_INTERFACE" : 11, 
	"LIBUSB_REQUEST_SYNCH_FRAME" : 12, 
}

libusb_request_recipient = { 
	"LIBUSB_RECIPIENT_DEVICE" : 0, 
	"LIBUSB_RECIPIENT_INTERFACE" : 1, 
	"LIBUSB_RECIPIENT_ENDPOINT" : 2, 
	"LIBUSB_RECIPIENT_OTHER" : 3, 
}

libusb_descriptor_type = { 
	"LIBUSB_DT_DEVICE" : 1, 
	"LIBUSB_DT_CONFIG" : 2, 
	"LIBUSB_DT_STRING" : 3, 
	"LIBUSB_DT_INTERFACE" : 4, 
	"LIBUSB_DT_ENDPOINT" : 5, 
	"LIBUSB_DT_HID" : 33, 
	"LIBUSB_DT_REPORT" : 34, 
	"LIBUSB_DT_PHYSICAL" : 35, 
	"LIBUSB_DT_HUB" : 41, 
}

libusb_iso_usage_type = { 
	"LIBUSB_ISO_USAGE_TYPE_DATA" : 0, 
	"LIBUSB_ISO_USAGE_TYPE_FEEDBACK" : 1, 
	"LIBUSB_ISO_USAGE_TYPE_IMPLICIT" : 2, 
}

libusb_class_code = { 
	"LIBUSB_CLASS_PER_INTERFACE" : 0, 
	"LIBUSB_CLASS_AUDIO" : 1, 
	"LIBUSB_CLASS_COMM" : 2, 
	"LIBUSB_CLASS_HID" : 3, 
	"LIBUSB_CLASS_PRINTER" : 7, 
	"LIBUSB_CLASS_PTP" : 6, 
	"LIBUSB_CLASS_MASS_STORAGE" : 8, 
	"LIBUSB_CLASS_HUB" : 9, 
	"LIBUSB_CLASS_DATA" : 10, 
	"LIBUSB_CLASS_WIRELESS" : 224, 
	"LIBUSB_CLASS_APPLICATION" : 254, 
	"LIBUSB_CLASS_VENDOR_SPEC" : 255, 
}

FREENECT_LOG_FATAL = 0 
FREENECT_LOG_ERROR = 1 
FREENECT_LOG_WARNING = 2 
FREENECT_LOG_NOTICE = 3 
FREENECT_LOG_INFO = 4 
FREENECT_LOG_DEBUG = 5 
FREENECT_LOG_SPEW = 6 
FREENECT_LOG_FLOOD = 7 

libusb_transfer_flags = { 
	"LIBUSB_TRANSFER_SHORT_NOT_OK" : 1, 
	"LIBUSB_TRANSFER_FREE_BUFFER" : 2, 
	"LIBUSB_TRANSFER_FREE_TRANSFER" : 4, 
}

libusb_transfer_status = { 
	"LIBUSB_TRANSFER_COMPLETED" : 0, 
	"LIBUSB_TRANSFER_ERROR" : 1, 
	"LIBUSB_TRANSFER_TIMED_OUT" : 2, 
	"LIBUSB_TRANSFER_CANCELLED" : 3, 
	"LIBUSB_TRANSFER_STALL" : 4, 
	"LIBUSB_TRANSFER_NO_DEVICE" : 5, 
	"LIBUSB_TRANSFER_OVERFLOW" : 6, 
}

libusb_error = { 
	"LIBUSB_SUCCESS" : 0, 
	"LIBUSB_ERROR_IO" : -1, 
	"LIBUSB_ERROR_INVALID_PARAM" : -2, 
	"LIBUSB_ERROR_ACCESS" : -3, 
	"LIBUSB_ERROR_NO_DEVICE" : -4, 
	"LIBUSB_ERROR_NOT_FOUND" : -5, 
	"LIBUSB_ERROR_BUSY" : -6, 
	"LIBUSB_ERROR_TIMEOUT" : -7, 
	"LIBUSB_ERROR_OVERFLOW" : -8, 
	"LIBUSB_ERROR_PIPE" : -9, 
	"LIBUSB_ERROR_INTERRUPTED" : -10, 
	"LIBUSB_ERROR_NO_MEM" : -11, 
	"LIBUSB_ERROR_NOT_SUPPORTED" : -12, 
	"LIBUSB_ERROR_OTHER" : -99, 
}

FREENECT_DEPTH_11BIT = 0 
FREENECT_DEPTH_10BIT = 1 
FREENECT_DEPTH_11BIT_PACKED = 2 
FREENECT_DEPTH_10BIT_PACKED = 3 

TILT_STATUS_STOPPED = 0 
TILT_STATUS_LIMIT = 1 
TILT_STATUS_MOVING = 4 

LED_OFF = 0 
LED_GREEN = 1 
LED_RED = 2 
LED_YELLOW = 3 
LED_BLINK_GREEN = 4 
LED_BLINK_RED_YELLOW = 6 

FREENECT_VIDEO_RGB = 0 
FREENECT_VIDEO_BAYER = 1 
FREENECT_VIDEO_IR_8BIT = 2 
FREENECT_VIDEO_IR_10BIT = 3 
FREENECT_VIDEO_IR_10BIT_PACKED = 4 
FREENECT_VIDEO_YUV_RGB = 5 
FREENECT_VIDEO_YUV_RAW = 6 

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 
 "FREENECT_LOG_FATAL" : 0,  "FREENECT_LOG_ERROR" : 1,  "FREENECT_LOG_WARNING" : 2,  "FREENECT_LOG_NOTICE" : 3,  "FREENECT_LOG_INFO" : 4,  "FREENECT_LOG_DEBUG" : 5,  "FREENECT_LOG_SPEW" : 6,  "FREENECT_LOG_FLOOD" : 7, 
 "FREENECT_DEPTH_11BIT" : 0,  "FREENECT_DEPTH_10BIT" : 1,  "FREENECT_DEPTH_11BIT_PACKED" : 2,  "FREENECT_DEPTH_10BIT_PACKED" : 3, 
 "TILT_STATUS_STOPPED" : 0,  "TILT_STATUS_LIMIT" : 1,  "TILT_STATUS_MOVING" : 4, 
 "LED_OFF" : 0,  "LED_GREEN" : 1,  "LED_RED" : 2,  "LED_YELLOW" : 3,  "LED_BLINK_GREEN" : 4,  "LED_BLINK_RED_YELLOW" : 6, 
 "FREENECT_VIDEO_RGB" : 0,  "FREENECT_VIDEO_BAYER" : 1,  "FREENECT_VIDEO_IR_8BIT" : 2,  "FREENECT_VIDEO_IR_10BIT" : 3,  "FREENECT_VIDEO_IR_10BIT_PACKED" : 4,  "FREENECT_VIDEO_YUV_RGB" : 5,  "FREENECT_VIDEO_YUV_RAW" : 6, 

}
class freenect_raw_tilt_state(_rpythonic_struct_): pass
class _freenect_context(_rpythonic_struct_): pass
class _freenect_device(_rpythonic_struct_): pass
class __fsid_t(_rpythonic_struct_): _array_wrapper_ = True
class timeval(_rpythonic_struct_): pass
class __sigset_t(_rpythonic_struct_): _array_wrapper_ = True
class timespec(_rpythonic_struct_): pass
class fd_set(_rpythonic_struct_): _array_wrapper_ = True
class timezone(_rpythonic_struct_): pass
class itimerval(_rpythonic_struct_): pass
class pthread_attr_t(ctypes.Union): pass
class __pthread_internal_slist(_rpythonic_struct_): pass
class pthread_mutex_t(ctypes.Union): pass
class __pthread_mutex_s(_rpythonic_struct_): pass
class pthread_mutexattr_t(ctypes.Union): pass
class pthread_cond_t(ctypes.Union): pass
class pthread_condattr_t(ctypes.Union): pass
class pthread_rwlock_t(ctypes.Union): pass
class __data(_rpythonic_struct_): pass
class pthread_rwlockattr_t(ctypes.Union): pass
class pthread_barrier_t(ctypes.Union): pass
class pthread_barrierattr_t(ctypes.Union): pass
class tm(_rpythonic_struct_): pass
class itimerspec(_rpythonic_struct_): pass
class sigevent(_rpythonic_struct_): pass
class __locale_struct(_rpythonic_struct_): _array_wrapper_ = True
class __locale_data(_rpythonic_struct_): pass
class libusb_device_descriptor(_rpythonic_struct_): pass
class libusb_endpoint_descriptor(_rpythonic_struct_): pass
class libusb_interface_descriptor(_rpythonic_struct_): pass
class libusb_interface(_rpythonic_struct_): pass
class libusb_config_descriptor(_rpythonic_struct_): pass
class libusb_control_setup(_rpythonic_struct_): pass
class libusb_context(_rpythonic_struct_): pass
class libusb_device(_rpythonic_struct_): pass
class libusb_device_handle(_rpythonic_struct_): pass
class libusb_iso_packet_descriptor(_rpythonic_struct_): pass
class libusb_transfer(_rpythonic_struct_): _array_wrapper_ = True
class libusb_pollfd(_rpythonic_struct_): pass
## union and structures ##
__freeze_rpythonic_struct( freenect_raw_tilt_state, [
	( "accelerometer_x", ctypes.c_int16 ),
	( "accelerometer_y", ctypes.c_int16 ),
	( "accelerometer_z", ctypes.c_int16 ),
	( "tilt_angle", ctypes.c_int8 ),
	( "tilt_status", ctypes.c_int ),
])

__freeze_rpythonic_struct( _freenect_context, [
])

__freeze_rpythonic_struct( _freenect_device, [
])

__freeze_rpythonic_struct( __fsid_t, [
	( "__val", ( ctypes.c_int * 2 ) ),
])

__freeze_rpythonic_struct( timeval, [
	( "tv_sec", ctypes.c_int64 ),
	( "tv_usec", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( __sigset_t, [
	( "__val", ctypes.c_uint64 ),
])

__freeze_rpythonic_struct( timespec, [
	( "tv_sec", ctypes.c_int64 ),
	( "tv_nsec", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( fd_set, [
	( "__fds_bits", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( timezone, [
	( "tz_minuteswest", ctypes.c_int ),
	( "tz_dsttime", ctypes.c_int ),
])

__freeze_rpythonic_struct( itimerval, [
	( "it_interval", timeval ),
	( "it_value", timeval ),
])

__freeze_rpythonic_struct( pthread_attr_t, [
	( "__size", ( ctypes.c_char * 36 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( __pthread_internal_slist, [
	( "__next", ctypes.POINTER(__pthread_internal_slist) ),
])

__freeze_rpythonic_struct( __pthread_mutex_s, [
	( "__lock", ctypes.c_int ),
	( "__count", ctypes.c_uint ),
	( "__owner", ctypes.c_int ),
	( "__kind", ctypes.c_int ),
	( "__nusers", ctypes.c_uint ),
	#opaque-warning# <rpythonic.rpythonic.SomeThing object at 0xace4f0c>
])

__freeze_rpythonic_struct( pthread_mutex_t, [
	( "__data", __pthread_mutex_s ),
	( "__size", ( ctypes.c_char * 24 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_mutexattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( __data, [
	( "__lock", ctypes.c_int ),
	( "__nr_readers", ctypes.c_uint ),
	( "__readers_wakeup", ctypes.c_uint ),
	( "__writer_wakeup", ctypes.c_uint ),
	( "__nr_readers_queued", ctypes.c_uint ),
	( "__nr_writers_queued", ctypes.c_uint ),
	( "__flags", ctypes.c_ubyte ),
	( "__shared", ctypes.c_ubyte ),
	( "__pad1", ctypes.c_ubyte ),
	( "__pad2", ctypes.c_ubyte ),
	( "__writer", ctypes.c_int ),
])

__freeze_rpythonic_struct( pthread_cond_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 48 ) ),
	( "__align", ctypes.c_longlong ),
])

__freeze_rpythonic_struct( pthread_condattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( pthread_rwlock_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 32 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_rwlockattr_t, [
	( "__size", ( ctypes.c_char * 8 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrier_t, [
	( "__size", ( ctypes.c_char * 20 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrierattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( tm, [
	( "tm_sec", ctypes.c_int ),
	( "tm_min", ctypes.c_int ),
	( "tm_hour", ctypes.c_int ),
	( "tm_mday", ctypes.c_int ),
	( "tm_mon", ctypes.c_int ),
	( "tm_year", ctypes.c_int ),
	( "tm_wday", ctypes.c_int ),
	( "tm_yday", ctypes.c_int ),
	( "tm_isdst", ctypes.c_int ),
	( "tm_gmtoff", ctypes.c_int64 ),
	( "tm_zone", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( itimerspec, [
	( "it_interval", timespec ),
	( "it_value", timespec ),
])

__freeze_rpythonic_struct( sigevent, [
])

__freeze_rpythonic_struct( __locale_data, [
])

__freeze_rpythonic_struct( __locale_struct, [
	( "__locales", ctypes.POINTER(( __locale_data * 13 )) ),
	( "__ctype_b", ctypes.POINTER(ctypes.c_uint16) ),
	( "__ctype_tolower", ctypes.POINTER(ctypes.c_int) ),
	( "__ctype_toupper", ctypes.POINTER(ctypes.c_int) ),
	( "__names", ctypes.POINTER(( ctypes.c_char * 13 )) ),
])

__freeze_rpythonic_struct( libusb_device_descriptor, [
	( "bLength", ctypes.c_uint8 ),
	( "bDescriptorType", ctypes.c_uint8 ),
	( "bcdUSB", ctypes.c_uint16 ),
	( "bDeviceClass", ctypes.c_uint8 ),
	( "bDeviceSubClass", ctypes.c_uint8 ),
	( "bDeviceProtocol", ctypes.c_uint8 ),
	( "bMaxPacketSize0", ctypes.c_uint8 ),
	( "idVendor", ctypes.c_uint16 ),
	( "idProduct", ctypes.c_uint16 ),
	( "bcdDevice", ctypes.c_uint16 ),
	( "iManufacturer", ctypes.c_uint8 ),
	( "iProduct", ctypes.c_uint8 ),
	( "iSerialNumber", ctypes.c_uint8 ),
	( "bNumConfigurations", ctypes.c_uint8 ),
])

__freeze_rpythonic_struct( libusb_endpoint_descriptor, [
	( "bLength", ctypes.c_uint8 ),
	( "bDescriptorType", ctypes.c_uint8 ),
	( "bEndpointAddress", ctypes.c_uint8 ),
	( "bmAttributes", ctypes.c_uint8 ),
	( "wMaxPacketSize", ctypes.c_uint16 ),
	( "bInterval", ctypes.c_uint8 ),
	( "bRefresh", ctypes.c_uint8 ),
	( "bSynchAddress", ctypes.c_uint8 ),
	( "extra", ctypes.POINTER(ctypes.c_ubyte) ),
	( "extra_length", ctypes.c_int ),
])

__freeze_rpythonic_struct( libusb_interface_descriptor, [
	( "bLength", ctypes.c_uint8 ),
	( "bDescriptorType", ctypes.c_uint8 ),
	( "bInterfaceNumber", ctypes.c_uint8 ),
	( "bAlternateSetting", ctypes.c_uint8 ),
	( "bNumEndpoints", ctypes.c_uint8 ),
	( "bInterfaceClass", ctypes.c_uint8 ),
	( "bInterfaceSubClass", ctypes.c_uint8 ),
	( "bInterfaceProtocol", ctypes.c_uint8 ),
	( "iInterface", ctypes.c_uint8 ),
	( "endpoint", ctypes.POINTER(libusb_endpoint_descriptor) ),
	( "extra", ctypes.POINTER(ctypes.c_ubyte) ),
	( "extra_length", ctypes.c_int ),
])

__freeze_rpythonic_struct( libusb_interface, [
	( "altsetting", ctypes.POINTER(libusb_interface_descriptor) ),
	( "num_altsetting", ctypes.c_int ),
])

__freeze_rpythonic_struct( libusb_config_descriptor, [
	( "bLength", ctypes.c_uint8 ),
	( "bDescriptorType", ctypes.c_uint8 ),
	( "wTotalLength", ctypes.c_uint16 ),
	( "bNumInterfaces", ctypes.c_uint8 ),
	( "bConfigurationValue", ctypes.c_uint8 ),
	( "iConfiguration", ctypes.c_uint8 ),
	( "bmAttributes", ctypes.c_uint8 ),
	( "MaxPower", ctypes.c_uint8 ),
	( "interface", ctypes.POINTER(libusb_interface) ),
	( "extra", ctypes.POINTER(ctypes.c_ubyte) ),
	( "extra_length", ctypes.c_int ),
])

__freeze_rpythonic_struct( libusb_control_setup, [
	( "bmRequestType", ctypes.c_uint8 ),
	( "bRequest", ctypes.c_uint8 ),
	( "wValue", ctypes.c_uint16 ),
	( "wIndex", ctypes.c_uint16 ),
	( "wLength", ctypes.c_uint16 ),
])

__freeze_rpythonic_struct( libusb_context, [
])

__freeze_rpythonic_struct( libusb_device, [
])

__freeze_rpythonic_struct( libusb_device_handle, [
])

__freeze_rpythonic_struct( libusb_iso_packet_descriptor, [
	( "length", ctypes.c_uint ),
	( "actual_length", ctypes.c_uint ),
	( "status", ctypes.c_int ),
])

__freeze_rpythonic_struct( libusb_transfer, [
	( "dev_handle", ctypes.POINTER(libusb_device_handle) ),
	( "flags", ctypes.c_uint8 ),
	( "endpoint", ctypes.c_ubyte ),
	( "C_type", ctypes.c_ubyte ),
	( "timeout", ctypes.c_uint ),
	( "status", ctypes.c_int ),
	( "length", ctypes.c_int ),
	( "actual_length", ctypes.c_int ),
	( "callback", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(libusb_transfer),) ),
	( "user_data", ctypes.POINTER(ctypes.c_void_p) ),
	( "buffer", ctypes.POINTER(ctypes.c_ubyte) ),
	( "num_iso_packets", ctypes.c_int ),
	( "iso_packet_desc", libusb_iso_packet_descriptor ),
])

__freeze_rpythonic_struct( libusb_pollfd, [
	( "fd", ctypes.c_int ),
	( "events", ctypes.c_short ),
])

## wrapper functions ##
libusb_free_config_descriptor = _rpythonic_function_(		"libusb_free_config_descriptor", ctypes.c_void_p, [
	("config",		ctypes.POINTER(libusb_config_descriptor)),] )

libusb_get_bus_number = _rpythonic_function_(		"libusb_get_bus_number", ctypes.c_uint8, [
	("dev",		ctypes.POINTER(libusb_device)),] )

libusb_alloc_transfer = _rpythonic_function_(		"libusb_alloc_transfer", ctypes.POINTER(libusb_transfer), [
	("iso_packets",		ctypes.c_int),] )

libusb_free_transfer = _rpythonic_function_(		"libusb_free_transfer", ctypes.c_void_p, [
	("transfer",		ctypes.POINTER(libusb_transfer)),] )

libusb_cancel_transfer = _rpythonic_function_(		"libusb_cancel_transfer", ctypes.c_int, [
	("transfer",		ctypes.POINTER(libusb_transfer)),] )

libusb_submit_transfer = _rpythonic_function_(		"libusb_submit_transfer", ctypes.c_int, [
	("transfer",		ctypes.POINTER(libusb_transfer)),] )

libusb_get_configuration = _rpythonic_function_(		"libusb_get_configuration", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("config",		ctypes.POINTER(ctypes.c_int)),] )

libusb_unref_device = _rpythonic_function_(		"libusb_unref_device", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(libusb_device)),] )

libusb_get_device_descriptor = _rpythonic_function_(		"libusb_get_device_descriptor", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("desc",		ctypes.POINTER(libusb_device_descriptor)),] )

libusb_ref_device = _rpythonic_function_(		"libusb_ref_device", ctypes.POINTER(libusb_device), [
	("dev",		ctypes.POINTER(libusb_device)),] )

libusb_get_config_descriptor = _rpythonic_function_(		"libusb_get_config_descriptor", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("config_index",		ctypes.c_uint8),
	("config",		ctypes.POINTER(ctypes.POINTER(libusb_config_descriptor))),] )

libusb_get_active_config_descriptor = _rpythonic_function_(		"libusb_get_active_config_descriptor", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("config",		ctypes.POINTER(ctypes.POINTER(libusb_config_descriptor))),] )

utimes = _rpythonic_function_(		"utimes", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__tvp",		( timeval * 2 )),] )

getitimer = _rpythonic_function_(		"getitimer", ctypes.c_int, [
	("__which",		ctypes.c_int),
	("__value",		ctypes.POINTER(itimerval)),] )

lutimes = _rpythonic_function_(		"lutimes", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__tvp",		( timeval * 2 )),] )

futimes = _rpythonic_function_(		"futimes", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__tvp",		( timeval * 2 )),] )

setitimer = _rpythonic_function_(		"setitimer", ctypes.c_int, [
	("__which",		ctypes.c_int),
	("__new",		ctypes.POINTER(itimerval)),
	("__old",		ctypes.POINTER(itimerval)),] )

adjtime = _rpythonic_function_(		"adjtime", ctypes.c_int, [
	("__delta",		ctypes.POINTER(timeval)),
	("__olddelta",		ctypes.POINTER(timeval)),] )

timer_getoverrun = _rpythonic_function_(		"timer_getoverrun", ctypes.c_int, [("__timerid",		ctypes.c_void_p)] )

timer_delete = _rpythonic_function_(		"timer_delete", ctypes.c_int, [("__timerid",		ctypes.c_void_p)] )

timer_settime = _rpythonic_function_(		"timer_settime", ctypes.c_int, [
	("__timerid",		ctypes.c_void_p),
	("__flags",		ctypes.c_int),
	("__value",		ctypes.POINTER(itimerspec)),
	("__ovalue",		ctypes.POINTER(itimerspec)),] )

timer_gettime = _rpythonic_function_(		"timer_gettime", ctypes.c_int, [
	("__timerid",		ctypes.c_void_p),
	("__value",		ctypes.POINTER(itimerspec)),] )

timer_create = _rpythonic_function_(		"timer_create", ctypes.c_int, [
	("__clock_id",		ctypes.c_int),
	("__evp",		ctypes.POINTER(sigevent)),
	("__timerid",		ctypes.POINTER(ctypes.c_void_p)),] )

libusb_unlock_events = _rpythonic_function_(		"libusb_unlock_events", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_lock_events = _rpythonic_function_(		"libusb_lock_events", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_try_lock_events = _rpythonic_function_(		"libusb_try_lock_events", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_event_handling_ok = _rpythonic_function_(		"libusb_event_handling_ok", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_get_string_descriptor_ascii = _rpythonic_function_(		"libusb_get_string_descriptor_ascii", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("index",		ctypes.c_uint8),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("length",		ctypes.c_int),] )

libusb_handle_events_timeout = _rpythonic_function_(		"libusb_handle_events_timeout", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("tv",		ctypes.POINTER(timeval)),] )

libusb_lock_event_waiters = _rpythonic_function_(		"libusb_lock_event_waiters", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_event_handler_active = _rpythonic_function_(		"libusb_event_handler_active", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_wait_for_event = _rpythonic_function_(		"libusb_wait_for_event", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("tv",		ctypes.POINTER(timeval)),] )

libusb_unlock_event_waiters = _rpythonic_function_(		"libusb_unlock_event_waiters", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_handle_events = _rpythonic_function_(		"libusb_handle_events", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

gmtime_r = _rpythonic_function_(		"gmtime_r", ctypes.POINTER(tm), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),
	("__tp",		ctypes.POINTER(tm)),] )

localtime = _rpythonic_function_(		"localtime", ctypes.POINTER(tm), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),] )

libusb_attach_kernel_driver = _rpythonic_function_(		"libusb_attach_kernel_driver", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("interface",		ctypes.c_int),] )

libusb_detach_kernel_driver = _rpythonic_function_(		"libusb_detach_kernel_driver", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("interface",		ctypes.c_int),] )

libusb_kernel_driver_active = _rpythonic_function_(		"libusb_kernel_driver_active", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("interface",		ctypes.c_int),] )

libusb_reset_device = _rpythonic_function_(		"libusb_reset_device", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),] )

asctime = _rpythonic_function_(		"asctime", ctypes.POINTER(ctypes.c_char), [
	("__tp",		ctypes.POINTER(tm)),] )

localtime_r = _rpythonic_function_(		"localtime_r", ctypes.POINTER(tm), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),
	("__tp",		ctypes.POINTER(tm)),] )

strftime = _rpythonic_function_(		"strftime", ctypes.c_uint, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__maxsize",		ctypes.c_uint),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__tp",		ctypes.POINTER(tm)),] )

mktime = _rpythonic_function_(		"mktime", ctypes.c_int64, [
	("__tp",		ctypes.POINTER(tm)),] )

libusb_get_max_packet_size = _rpythonic_function_(		"libusb_get_max_packet_size", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("endpoint",		ctypes.c_ubyte),] )

libusb_get_max_iso_packet_size = _rpythonic_function_(		"libusb_get_max_iso_packet_size", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("endpoint",		ctypes.c_ubyte),] )

libusb_get_device_address = _rpythonic_function_(		"libusb_get_device_address", ctypes.c_uint8, [
	("dev",		ctypes.POINTER(libusb_device)),] )

libusb_get_config_descriptor_by_value = _rpythonic_function_(		"libusb_get_config_descriptor_by_value", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("bConfigurationValue",		ctypes.c_uint8),
	("config",		ctypes.POINTER(ctypes.POINTER(libusb_config_descriptor))),] )

libusb_handle_events_locked = _rpythonic_function_(		"libusb_handle_events_locked", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("tv",		ctypes.POINTER(timeval)),] )

libusb_pollfds_handle_timeouts = _rpythonic_function_(		"libusb_pollfds_handle_timeouts", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

libusb_get_next_timeout = _rpythonic_function_(		"libusb_get_next_timeout", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("tv",		ctypes.POINTER(timeval)),] )

libusb_pollfd_added_cb = _rpythonic_function_(		"libusb_pollfd_added_cb", ctypes.c_void_p, [
	("fd",		ctypes.c_int),
	("events",		ctypes.c_short),
	("user_data",		ctypes.POINTER(ctypes.c_void_p)),] )

libusb_pollfd_removed_cb = _rpythonic_function_(		"libusb_pollfd_removed_cb", ctypes.c_void_p, [
	("fd",		ctypes.c_int),
	("user_data",		ctypes.POINTER(ctypes.c_void_p)),] )

libusb_get_pollfds = _rpythonic_function_(		"libusb_get_pollfds", ctypes.POINTER(ctypes.POINTER(libusb_pollfd)), [
	("ctx",		ctypes.POINTER(libusb_context)),] )

select = _rpythonic_function_(		"select", ctypes.c_int, [
	("__nfds",		ctypes.c_int),
	("__readfds",		ctypes.POINTER(fd_set)),
	("__writefds",		ctypes.POINTER(fd_set)),
	("__exceptfds",		ctypes.POINTER(fd_set)),
	("__timeout",		ctypes.POINTER(timeval)),] )

pselect = _rpythonic_function_(		"pselect", ctypes.c_int, [
	("__nfds",		ctypes.c_int),
	("__readfds",		ctypes.POINTER(fd_set)),
	("__writefds",		ctypes.POINTER(fd_set)),
	("__exceptfds",		ctypes.POINTER(fd_set)),
	("__timeout",		ctypes.POINTER(timespec)),
	("__sigmask",		ctypes.POINTER(__sigset_t)),] )

gettimeofday = _rpythonic_function_(		"gettimeofday", ctypes.c_int, [
	("__tv",		ctypes.POINTER(timeval)),
	("__tz",		ctypes.POINTER(timezone)),] )

settimeofday = _rpythonic_function_(		"settimeofday", ctypes.c_int, [
	("__tv",		ctypes.POINTER(timeval)),
	("__tz",		ctypes.POINTER(timezone)),] )

freenect_sync_get_tilt_state = _rpythonic_function_(		"freenect_sync_get_tilt_state", ctypes.c_int, [
	("state",		ctypes.POINTER(ctypes.POINTER(freenect_raw_tilt_state))),
	("index",		ctypes.c_int),] )

freenect_sync_set_led = _rpythonic_function_(		"freenect_sync_set_led", ctypes.c_int, [
	("led",		ctypes.c_int),
	("index",		ctypes.c_int),] )

freenect_sync_stop = _rpythonic_function_(		"freenect_sync_stop", ctypes.c_void_p, [] )

gnu_dev_major = _rpythonic_function_(		"gnu_dev_major", ctypes.c_uint, [
	("__dev",		ctypes.c_ulonglong),] )

gnu_dev_minor = _rpythonic_function_(		"gnu_dev_minor", ctypes.c_uint, [
	("__dev",		ctypes.c_ulonglong),] )

gnu_dev_makedev = _rpythonic_function_(		"gnu_dev_makedev", ctypes.c_ulonglong, [
	("__major",		ctypes.c_uint),
	("__minor",		ctypes.c_uint),] )

clock = _rpythonic_function_(		"clock", ctypes.c_int64, [] )

time = _rpythonic_function_(		"time", ctypes.c_int64, [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),] )

difftime = _rpythonic_function_(		"difftime", ctypes.c_double, [
	("__time1",		ctypes.c_int64),
	("__time0",		ctypes.c_int64),] )

tzset = _rpythonic_function_(		"tzset", ctypes.c_void_p, [] )

clock_getres = _rpythonic_function_(		"clock_getres", ctypes.c_int, [
	("__clock_id",		ctypes.c_int),
	("__res",		ctypes.POINTER(timespec)),] )

nanosleep = _rpythonic_function_(		"nanosleep", ctypes.c_int, [
	("__requested_time",		ctypes.POINTER(timespec)),
	("__remaining",		ctypes.POINTER(timespec)),] )

stime = _rpythonic_function_(		"stime", ctypes.c_int, [
	("__when",		ctypes.POINTER(ctypes.c_int64)),] )

timegm = _rpythonic_function_(		"timegm", ctypes.c_int64, [
	("__tp",		ctypes.POINTER(tm)),] )

clock_gettime = _rpythonic_function_(		"clock_gettime", ctypes.c_int, [
	("__clock_id",		ctypes.c_int),
	("__tp",		ctypes.POINTER(timespec)),] )

timelocal = _rpythonic_function_(		"timelocal", ctypes.c_int64, [
	("__tp",		ctypes.POINTER(tm)),] )

dysize = _rpythonic_function_(		"dysize", ctypes.c_int, [
	("__year",		ctypes.c_int),] )

libusb_set_pollfd_notifiers = _rpythonic_function_(		"libusb_set_pollfd_notifiers", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("added_cb",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,ctypes.c_short,ctypes.POINTER(ctypes.c_void_p),)),
	("removed_cb",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,ctypes.POINTER(ctypes.c_void_p),)),
	("user_data",		ctypes.POINTER(ctypes.c_void_p)),] )

freenect_set_log_level = _rpythonic_function_(		"freenect_set_log_level", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(_freenect_context)),
	("level",		ctypes.c_int),] )

freenect_log_cb = _rpythonic_function_(		"freenect_log_cb", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_context)),
	("level",		ctypes.c_int),
	("msg",		ctypes.POINTER(ctypes.c_char)),] )

freenect_shutdown = _rpythonic_function_(		"freenect_shutdown", ctypes.c_int, [
	("ctx",		ctypes.POINTER(_freenect_context)),] )

freenect_set_log_callback = _rpythonic_function_(		"freenect_set_log_callback", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(_freenect_context)),
	("cb",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(_freenect_context),ctypes.c_int,ctypes.POINTER(ctypes.c_char),)),] )

freenect_init = _rpythonic_function_(		"freenect_init", ctypes.c_int, [
	("ctx",		ctypes.POINTER(ctypes.POINTER(_freenect_context))),
	("usb_ctx",		ctypes.POINTER(libusb_context)),] )

freenect_process_events = _rpythonic_function_(		"freenect_process_events", ctypes.c_int, [
	("ctx",		ctypes.POINTER(_freenect_context)),] )

freenect_num_devices = _rpythonic_function_(		"freenect_num_devices", ctypes.c_int, [
	("ctx",		ctypes.POINTER(_freenect_context)),] )

freenect_set_depth_format = _rpythonic_function_(		"freenect_set_depth_format", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("fmt",		ctypes.c_int),] )

freenect_set_video_format = _rpythonic_function_(		"freenect_set_video_format", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("fmt",		ctypes.c_int),] )

freenect_set_depth_buffer = _rpythonic_function_(		"freenect_set_depth_buffer", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("buf",		ctypes.POINTER(ctypes.c_void_p)),] )

freenect_set_video_buffer = _rpythonic_function_(		"freenect_set_video_buffer", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("buf",		ctypes.POINTER(ctypes.c_void_p)),] )

freenect_start_depth = _rpythonic_function_(		"freenect_start_depth", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_start_video = _rpythonic_function_(		"freenect_start_video", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_stop_depth = _rpythonic_function_(		"freenect_stop_depth", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_stop_video = _rpythonic_function_(		"freenect_stop_video", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_update_tilt_state = _rpythonic_function_(		"freenect_update_tilt_state", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_get_tilt_state = _rpythonic_function_(		"freenect_get_tilt_state", ctypes.POINTER(freenect_raw_tilt_state), [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_open_device = _rpythonic_function_(		"freenect_open_device", ctypes.c_int, [
	("ctx",		ctypes.POINTER(_freenect_context)),
	("dev",		ctypes.POINTER(ctypes.POINTER(_freenect_device))),
	("index",		ctypes.c_int),] )

freenect_close_device = _rpythonic_function_(		"freenect_close_device", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_set_user = _rpythonic_function_(		"freenect_set_user", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("user",		ctypes.POINTER(ctypes.c_void_p)),] )

freenect_get_user = _rpythonic_function_(		"freenect_get_user", ctypes.POINTER(ctypes.c_void_p), [
	("dev",		ctypes.POINTER(_freenect_device)),] )

freenect_depth_cb = _rpythonic_function_(		"freenect_depth_cb", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("depth",		ctypes.POINTER(ctypes.c_void_p)),
	("timestamp",		ctypes.c_uint32),] )

freenect_video_cb = _rpythonic_function_(		"freenect_video_cb", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("video",		ctypes.POINTER(ctypes.c_void_p)),
	("timestamp",		ctypes.c_uint32),] )

freenect_set_depth_callback = _rpythonic_function_(		"freenect_set_depth_callback", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("cb",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(_freenect_device),ctypes.POINTER(ctypes.c_void_p),ctypes.c_uint32,)),] )

freenect_set_video_callback = _rpythonic_function_(		"freenect_set_video_callback", ctypes.c_void_p, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("cb",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(_freenect_device),ctypes.POINTER(ctypes.c_void_p),ctypes.c_uint32,)),] )

freenect_set_tilt_degs = _rpythonic_function_(		"freenect_set_tilt_degs", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("angle",		ctypes.c_double),] )

freenect_get_tilt_status = _rpythonic_function_(		"freenect_get_tilt_status", ctypes.c_int, [
	("state",		ctypes.POINTER(freenect_raw_tilt_state)),] )

freenect_set_led = _rpythonic_function_(		"freenect_set_led", ctypes.c_int, [
	("dev",		ctypes.POINTER(_freenect_device)),
	("option",		ctypes.c_int),] )

freenect_get_mks_accel = _rpythonic_function_(		"freenect_get_mks_accel", ctypes.c_void_p, [
	("state",		ctypes.POINTER(freenect_raw_tilt_state)),
	("x",		ctypes.POINTER(ctypes.c_double)),
	("y",		ctypes.POINTER(ctypes.c_double)),
	("z",		ctypes.POINTER(ctypes.c_double)),] )

freenect_sync_get_video = _rpythonic_function_(		"freenect_sync_get_video", ctypes.c_int, [
	("video",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("timestamp",		ctypes.POINTER(ctypes.c_uint32)),
	("index",		ctypes.c_int),
	("fmt",		ctypes.c_int),] )

freenect_get_tilt_degs = _rpythonic_function_(		"freenect_get_tilt_degs", ctypes.c_double, [
	("state",		ctypes.POINTER(freenect_raw_tilt_state)),] )

freenect_sync_get_depth = _rpythonic_function_(		"freenect_sync_get_depth", ctypes.c_int, [
	("depth",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("timestamp",		ctypes.POINTER(ctypes.c_uint32)),
	("index",		ctypes.c_int),
	("fmt",		ctypes.c_int),] )

freenect_sync_set_tilt_degs = _rpythonic_function_(		"freenect_sync_set_tilt_degs", ctypes.c_int, [
	("angle",		ctypes.c_int),
	("index",		ctypes.c_int),] )

libusb_transfer_cb_fn = _rpythonic_function_(		"libusb_transfer_cb_fn", ctypes.c_void_p, [
	("transfer",		ctypes.POINTER(libusb_transfer)),] )

ctime = _rpythonic_function_(		"ctime", ctypes.POINTER(ctypes.c_char), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),] )

ctime_r = _rpythonic_function_(		"ctime_r", ctypes.POINTER(ctypes.c_char), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),] )

asctime_r = _rpythonic_function_(		"asctime_r", ctypes.POINTER(ctypes.c_char), [
	("__tp",		ctypes.POINTER(tm)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),] )

strftime_l = _rpythonic_function_(		"strftime_l", ctypes.c_uint, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__maxsize",		ctypes.c_uint),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__tp",		ctypes.POINTER(tm)),
	("__loc",		ctypes.POINTER(__locale_struct)),] )

gmtime = _rpythonic_function_(		"gmtime", ctypes.POINTER(tm), [
	("__timer",		ctypes.POINTER(ctypes.c_int64)),] )

libusb_free_device_list = _rpythonic_function_(		"libusb_free_device_list", ctypes.c_void_p, [
	("C_list",		ctypes.POINTER(ctypes.POINTER(libusb_device))),
	("unref_devices",		ctypes.c_int),] )

libusb_get_device_list = _rpythonic_function_(		"libusb_get_device_list", ctypes.c_int, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("C_list",		ctypes.POINTER(ctypes.POINTER(ctypes.POINTER(libusb_device)))),] )

libusb_init = _rpythonic_function_(		"libusb_init", ctypes.c_int, [
	("ctx",		ctypes.POINTER(ctypes.POINTER(libusb_context))),] )

libusb_set_debug = _rpythonic_function_(		"libusb_set_debug", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),
	("level",		ctypes.c_int),] )

libusb_exit = _rpythonic_function_(		"libusb_exit", ctypes.c_void_p, [
	("ctx",		ctypes.POINTER(libusb_context)),] )

clock_nanosleep = _rpythonic_function_(		"clock_nanosleep", ctypes.c_int, [
	("__clock_id",		ctypes.c_int),
	("__flags",		ctypes.c_int),
	("__req",		ctypes.POINTER(timespec)),
	("__rem",		ctypes.POINTER(timespec)),] )

clock_getcpuclockid = _rpythonic_function_(		"clock_getcpuclockid", ctypes.c_int, [
	("__pid",		ctypes.c_int),
	("__clock_id",		ctypes.POINTER(ctypes.c_int)),] )

clock_settime = _rpythonic_function_(		"clock_settime", ctypes.c_int, [
	("__clock_id",		ctypes.c_int),
	("__tp",		ctypes.POINTER(timespec)),] )

libusb_bulk_transfer = _rpythonic_function_(		"libusb_bulk_transfer", ctypes.c_int, [
	("dev_handle",		ctypes.POINTER(libusb_device_handle)),
	("endpoint",		ctypes.c_ubyte),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("length",		ctypes.c_int),
	("actual_length",		ctypes.POINTER(ctypes.c_int)),
	("timeout",		ctypes.c_uint),] )

libusb_interrupt_transfer = _rpythonic_function_(		"libusb_interrupt_transfer", ctypes.c_int, [
	("dev_handle",		ctypes.POINTER(libusb_device_handle)),
	("endpoint",		ctypes.c_ubyte),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("length",		ctypes.c_int),
	("actual_length",		ctypes.POINTER(ctypes.c_int)),
	("timeout",		ctypes.c_uint),] )

libusb_release_interface = _rpythonic_function_(		"libusb_release_interface", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("iface",		ctypes.c_int),] )

libusb_open_device_with_vid_pid = _rpythonic_function_(		"libusb_open_device_with_vid_pid", ctypes.POINTER(libusb_device_handle), [
	("ctx",		ctypes.POINTER(libusb_context)),
	("vendor_id",		ctypes.c_uint16),
	("product_id",		ctypes.c_uint16),] )

libusb_clear_halt = _rpythonic_function_(		"libusb_clear_halt", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("endpoint",		ctypes.c_ubyte),] )

libusb_set_configuration = _rpythonic_function_(		"libusb_set_configuration", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("configuration",		ctypes.c_int),] )

libusb_open = _rpythonic_function_(		"libusb_open", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device)),
	("handle",		ctypes.POINTER(ctypes.POINTER(libusb_device_handle))),] )

libusb_get_device = _rpythonic_function_(		"libusb_get_device", ctypes.POINTER(libusb_device), [
	("dev_handle",		ctypes.POINTER(libusb_device_handle)),] )

libusb_set_interface_alt_setting = _rpythonic_function_(		"libusb_set_interface_alt_setting", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("interface_number",		ctypes.c_int),
	("alternate_setting",		ctypes.c_int),] )

libusb_close = _rpythonic_function_(		"libusb_close", ctypes.c_void_p, [
	("dev_handle",		ctypes.POINTER(libusb_device_handle)),] )

libusb_claim_interface = _rpythonic_function_(		"libusb_claim_interface", ctypes.c_int, [
	("dev",		ctypes.POINTER(libusb_device_handle)),
	("iface",		ctypes.c_int),] )

libusb_control_transfer = _rpythonic_function_(		"libusb_control_transfer", ctypes.c_int, [
	("dev_handle",		ctypes.POINTER(libusb_device_handle)),
	("request_type",		ctypes.c_uint8),
	("request",		ctypes.c_uint8),
	("value",		ctypes.c_uint16),
	("index",		ctypes.c_uint16),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("length",		ctypes.c_uint16),
	("timeout",		ctypes.c_uint),] )


_rpythonic_convert_structs_to_objects()

_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()

################### Raymond Hettinger's Constant Folding ##################
# Decorator for BindingConstants at compile time
# A recipe by Raymond Hettinger, from Python Cookbook:
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940
# updated for Python3 and still compatible with Python2 - by Hart, May17th 2011

try: _BUILTINS_DICT_ = vars(__builtins__)
except: _BUILTINS_DICT_ = __builtins__
ISPYTHON2 = sys.version_info[0] == 2
_HETTINGER_FOLDS_ = 0

def _hettinger_make_constants(f, builtin_only=False, stoplist=[], verbose=0):
    from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
    global _HETTINGER_FOLDS_
    try:
        if ISPYTHON2: co = f.func_code; fname = f.func_name
        else: co = f.__code__; fname = f.__name__
    except AttributeError: return f        # Jython doesn't have a func_code attribute.
    if ISPYTHON2: newcode = map(ord, co.co_code)
    else: newcode = list( co.co_code )
    newconsts = list(co.co_consts)
    names = co.co_names
    codelen = len(newcode)
    if ISPYTHON2:
        if verbose >= 2: print( f.func_name )
        func_globals = f.func_globals
    else:
        if verbose >= 2: print( f.__name__ )
        func_globals = f.__globals__

    env = _BUILTINS_DICT_.copy()
    if builtin_only:
        stoplist = dict.fromkeys(stoplist)
        stoplist.update(func_globals)
    else:
        env.update(func_globals)

    # First pass converts global lookups into constants
    i = 0
    while i < codelen:
        opcode = newcode[i]
        if opcode in (EXTENDED_ARG, opmap['STORE_GLOBAL']):
            if verbose >= 1: print('skipping function', fname)
            return f    # for simplicity, only optimize common cases
        if opcode == opmap['LOAD_GLOBAL']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = co.co_names[oparg]
            if name in env and name not in stoplist:
                value = env[name]
                for pos, v in enumerate(newconsts):
                    if v is value:
                        break
                else:
                    pos = len(newconsts)
                    newconsts.append(value)
                newcode[i] = opmap['LOAD_CONST']
                newcode[i+1] = pos & 0xFF
                newcode[i+2] = pos >> 8
                _HETTINGER_FOLDS_ += 1
                if verbose >= 2:
                    print( "    global constant fold:", name )
        i += 1
        if opcode >= HAVE_ARGUMENT:
            i += 2

    # Second pass folds tuples of constants and constant attribute lookups
    i = 0
    while i < codelen:

        newtuple = []
        while newcode[i] == opmap['LOAD_CONST']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            newtuple.append(newconsts[oparg])
            i += 3

        opcode = newcode[i]
        if not newtuple:
            i += 1
            if opcode >= HAVE_ARGUMENT:
                i += 2
            continue

        if opcode == opmap['LOAD_ATTR']:
            obj = newtuple[-1]
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = names[oparg]
            try:
                value = getattr(obj, name)
                if verbose >= 2: print( '    folding attribute', name )
            except AttributeError:
                continue
            deletions = 1

        elif opcode == opmap['BUILD_TUPLE']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            if oparg != len(newtuple): continue
            deletions = len(newtuple)
            value = tuple(newtuple)

        else: continue

        reljump = deletions * 3
        newcode[i-reljump] = opmap['JUMP_FORWARD']
        newcode[i-reljump+1] = (reljump-3) & 0xFF
        newcode[i-reljump+2] = (reljump-3) >> 8

        n = len(newconsts)
        newconsts.append(value)
        newcode[i] = opmap['LOAD_CONST']
        newcode[i+1] = n & 0xFF
        newcode[i+2] = n >> 8
        i += 3
        _HETTINGER_FOLDS_ += 1
        if verbose >= 2:
            print( "    folded constant:",value )

    if ISPYTHON2:
        codestr = ''.join(map(chr, newcode))
        codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults, f.func_closure)
    else:
        codestr = b''
        for s in newcode: codestr += s.to_bytes(1,'little')
        codeobj = type(co)(co.co_argcount, co.co_kwonlyargcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.__globals__, f.__name__, f.__defaults__, f.__closure__)


def hettinger_bind_recursive(mc, builtin_only=False, stoplist=[],  verbose=0):
    """Recursively apply constant binding to functions in a module or class.

    Use as the last line of the module (after everything is defined, but
    before test code).  In modules that need modifiable globals, set
    builtin_only to True.

    """
    import types
    try: d = vars(mc)
    except TypeError: return
    if ISPYTHON2: recursivetypes = (type, types.ClassType)
    else: recursivetypes = (type,)
    for k, v in d.items():
        if type(v) is types.FunctionType:
            newv = _hettinger_make_constants(v, builtin_only, stoplist,  verbose)
            setattr(mc, k, newv)
        elif type(v) in recursivetypes:
            hettinger_bind_recursive(v, builtin_only, stoplist, verbose)

def hettinger_transform( module=None ):
    global _HETTINGER_FOLDS_
    _HETTINGER_FOLDS_ = 0
    if not module: module = sys.modules[__name__]
    hettinger_bind_recursive( module, verbose=1 )
    print( 'HETTINGER: constants folded', _HETTINGER_FOLDS_ )
