#!/usr/bin/python
# RPythonic - May 25th, 2011
# By HartsAntler, bhartsho@yahoo.com
# License: BSD
VERSION = '0.3.6pre14'

# py3k compat

import os, sys, ctypes, inspect
import subprocess


try:
	import CppHeaderParser
	print( 'loaded CppHeaderParser' )
	import pycparser		# including pycparser-2.03
	print( 'loaded pycparser' )
	# byteplay-0.2+ git version is UNSTABLE
	#if sys.version_info.major == 2:
	#	import byteplay		
	#elif sys.version_info.major == 3:
	#	import byteplay3 as byteplay

except:
	print( 'MESSAGE: failed to import pycparser - rpythonic can not generate new wrappers' )
	pycparser = None


RPYTHONIC_DIR = os.path.split(os.path.abspath(__file__))[0]
CTYPES_HEADER = '## generated by RPythonic %s\n' % VERSION
CTYPES_HEADER += '## http://code.google.com/p/rpythonic/'
CTYPES_HEADER += '\n' + open( os.path.join(RPYTHONIC_DIR,'_ctypesheader_.py'), 'rb' ).read().decode('utf-8')



_doc_ = '''
NAME
	RPythonic

DESCRIPTION
	RPythonic is a frontend for using RPython (the translation toolchain of PyPy), it simplifies: wrapper generation, compiling (standalone or modules), and Android integration.  It can also be used as a tool to automatically wrap C libraries using ctypes.

INSTALLING
		PLY (apt-get install python-ply)
		python setup.py install

RPYTHON API
	import rpythonic
	rpythonic.set_pypy_root( '../../pypy' )
	rpy = rpythonic.RPython()
	@rpy.bind(a=float, b=float)
	def sub( a, b ): return a-b
	rpy.cache('test1')
	sub(10,100)		# compiled

WRAPPER API
	import rpythonic
	try: module = rpythonic.load( 'OpenNI' )
	except: module = rpythonic.wrap( 'OpenNI', header='/usr/include/ni/XnOpenNI.h', library='/usr/lib/libOpenNI.so' )


'''

# TODO enable inlining
# func._dont_inline_ = True 
# func._always_inline_ = True
# stackless test1 - april25
#flow space unrolls loops
#wrapped = rlib.unrolling_iterable( somelist )
# moving to using secondary_entrypoints using carbonpython's style
#apt-get install libgc-dev
#apt-get install git-core cmake libglut3-dev pkg-config build-essential libxmu-dev libxi-dev libusb-1.0-0-dev


#############################################################
# from pypy/translator/stackless/transform.py
# a simple example of what the stackless transform does
#
# def func(x):
#     return g() + x + 1
#
# STATE_func_0 = lltype.Struct('STATE_func_0',
#                              ('header', STATE_HEADER),
#                              ('saved_long_0', Signed))
#
# def func(x):
#     state = global_state.restart_substate
#     if state == -1:   # normal case
#         try:
#             retval = g(x)
#         except code.UnwindException, u:
#             state = lltype.malloc(STATE_func_0, flavor='gc_nocollect')
#             state.header.f_restart = <index in array of frame.FRAMEINFO>
#             state.saved_long_0 = x
#             code.add_frame_state(u, state.header)
#             raise
#     elif state == 0:
#         global_state.restart_substate = -1
#         state = lltype.cast_pointer(lltype.Ptr(STATE_func_0),
#                                     global_state.top)
#         global_state.top = null_state
#         x = state.saved_long_0
#         retval = code.fetch_retval_long() # can raise an exception
#     elif state == 1:
#         ...
#     elif state == 2:
#         ...
#     else:
#         abort()
#     return retval + x + 1



IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)
SEM_NAME = '/rpython_mutex'
PATH2PYPY = '../pypy'


RAYMOND_HETTINGER = '''
################### Raymond Hettinger's Constant Folding ##################
# Decorator for BindingConstants at compile time
# A recipe by Raymond Hettinger, from Python Cookbook:
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940
# updated for Python3 and still compatible with Python2 - by Hart, May17th 2011

try: _BUILTINS_DICT_ = vars(__builtins__)
except: _BUILTINS_DICT_ = __builtins__
ISPYTHON2 = sys.version_info[0] == 2
_HETTINGER_FOLDS_ = 0

def _hettinger_make_constants(f, builtin_only=False, stoplist=[], verbose=0):
    from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
    global _HETTINGER_FOLDS_
    try:
        if ISPYTHON2: co = f.func_code; fname = f.func_name
        else: co = f.__code__; fname = f.__name__
    except AttributeError: return f        # Jython doesn't have a func_code attribute.
    if ISPYTHON2: newcode = map(ord, co.co_code)
    else: newcode = list( co.co_code )
    newconsts = list(co.co_consts)
    names = co.co_names
    codelen = len(newcode)
    if ISPYTHON2:
        if verbose >= 2: print( f.func_name )
        func_globals = f.func_globals
    else:
        if verbose >= 2: print( f.__name__ )
        func_globals = f.__globals__

    env = _BUILTINS_DICT_.copy()
    if builtin_only:
        stoplist = dict.fromkeys(stoplist)
        stoplist.update(func_globals)
    else:
        env.update(func_globals)

    # First pass converts global lookups into constants
    i = 0
    while i < codelen:
        opcode = newcode[i]
        if opcode in (EXTENDED_ARG, opmap['STORE_GLOBAL']):
            if verbose >= 1: print('skipping function', fname)
            return f    # for simplicity, only optimize common cases
        if opcode == opmap['LOAD_GLOBAL']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = co.co_names[oparg]
            if name in env and name not in stoplist:
                value = env[name]
                for pos, v in enumerate(newconsts):
                    if v is value:
                        break
                else:
                    pos = len(newconsts)
                    newconsts.append(value)
                newcode[i] = opmap['LOAD_CONST']
                newcode[i+1] = pos & 0xFF
                newcode[i+2] = pos >> 8
                _HETTINGER_FOLDS_ += 1
                if verbose >= 2:
                    print( "    global constant fold:", name )
        i += 1
        if opcode >= HAVE_ARGUMENT:
            i += 2

    # Second pass folds tuples of constants and constant attribute lookups
    i = 0
    while i < codelen:

        newtuple = []
        while newcode[i] == opmap['LOAD_CONST']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            newtuple.append(newconsts[oparg])
            i += 3

        opcode = newcode[i]
        if not newtuple:
            i += 1
            if opcode >= HAVE_ARGUMENT:
                i += 2
            continue

        if opcode == opmap['LOAD_ATTR']:
            obj = newtuple[-1]
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = names[oparg]
            try:
                value = getattr(obj, name)
                if verbose >= 2: print( '    folding attribute', name )
            except AttributeError:
                continue
            deletions = 1

        elif opcode == opmap['BUILD_TUPLE']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            if oparg != len(newtuple): continue
            deletions = len(newtuple)
            value = tuple(newtuple)

        else: continue

        reljump = deletions * 3
        newcode[i-reljump] = opmap['JUMP_FORWARD']
        newcode[i-reljump+1] = (reljump-3) & 0xFF
        newcode[i-reljump+2] = (reljump-3) >> 8

        n = len(newconsts)
        newconsts.append(value)
        newcode[i] = opmap['LOAD_CONST']
        newcode[i+1] = n & 0xFF
        newcode[i+2] = n >> 8
        i += 3
        _HETTINGER_FOLDS_ += 1
        if verbose >= 2:
            print( "    folded constant:",value )

    if ISPYTHON2:
        codestr = ''.join(map(chr, newcode))
        codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults, f.func_closure)
    else:
        codestr = b''
        for s in newcode: codestr += s.to_bytes(1,'little')
        codeobj = type(co)(co.co_argcount, co.co_kwonlyargcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.__globals__, f.__name__, f.__defaults__, f.__closure__)


def hettinger_bind_recursive(mc, builtin_only=False, stoplist=[],  verbose=0):
    """Recursively apply constant binding to functions in a module or class.

    Use as the last line of the module (after everything is defined, but
    before test code).  In modules that need modifiable globals, set
    builtin_only to True.

    """
    import types
    try: d = vars(mc)
    except TypeError: return
    if ISPYTHON2: recursivetypes = (type, types.ClassType)
    else: recursivetypes = (type,)
    for k, v in d.items():
        if type(v) is types.FunctionType:
            newv = _hettinger_make_constants(v, builtin_only, stoplist,  verbose)
            setattr(mc, k, newv)
        elif type(v) in recursivetypes:
            hettinger_bind_recursive(v, builtin_only, stoplist, verbose)

def hettinger_transform( module=None ):
    global _HETTINGER_FOLDS_
    _HETTINGER_FOLDS_ = 0
    if not module: module = sys.modules[__name__]
    hettinger_bind_recursive( module, verbose=1 )
    print( 'HETTINGER: constants folded', _HETTINGER_FOLDS_ )
'''
################### END Raymond Hettinger's Constant Folding ##################
exec( RAYMOND_HETTINGER )


def pprint( txt, color=None ):
	if color and sys.platform != "win32": print( '\x1b[%sm'%color + str(txt) + '\x1b[0m' )
	else: print( txt )

CACHEDIR = None
def set_cache( path ):
	global CACHEDIR
	assert os.path.isdir( path )
	CACHEDIR = path
	if CACHEDIR not in sys.path: sys.path.append( CACHEDIR )
set_cache( os.path.join( RPYTHONIC_DIR, 'cache' ) )

def set_pypy_root( path ):
	global PATH2PYPY
	path = os.path.abspath( path )
	assert os.path.isdir( path )
	PATH2PYPY = path
	if path not in sys.path: sys.path.append( PATH2PYPY )


def set_android_sdk_root(path): Android.set_sdk_root( path )
def set_android_ndk_root(path): Android.set_ndk_root( path )



def _load( name, type, platform='' ):
	return __import__( 
		'gen%s%s.%s'%(type,platform,name), 
		fromlist=[name] 
	)

def load( name, mode='ctypes', platform='', debug=True ):	# load module
	mod = None
	if debug: mod = _load( name, mode, platform )
	else:
		try: mod = _load( name, mode, platform )
		except: print( 'failed to load module', name )
	return mod

class ModuleWrapper(object):
	## backdoor to define manual wrappers
	# module( somefunc, returns, arg )
	def __call__(self, name, result=ctypes.c_void_p, *args ):
		_args = args
		if args and type(args[0]) not in (tuple,list):
			_args = []
			for i, arg in enumerate( args ):
				_args.append( ('unnamed%s'%i, arg) )
		return self.__module._rpythonic_function_( name, result, _args )

	def __init__(self, name, module, secondary=None):
		self.__name = name
		self.__module = module
		self.__secondary = secondary
		ignorelist = getattr( module, 'RPYTHONIC_AUTOPREFIX_IGNORE' )
		count = {}
		for n in dir( module ):
			if len(n)>=3:
				a = ''
				for i,char in enumerate( n ):
					if i != 0:
						if char.isupper(): break	# camelCase or CamelCase or prefix_name
						elif char == '_': a += '_'; break
					a += char
				if len(a) < len(n):
					if a not in count: count[a] = 0
					count[a] += 1
		self.__try_names = []
		for n in count:
			if count[n] > 20 and n not in ignorelist:
				print( 'auto prefix', n )
				self.__try_names.append( n )

	def __getattr__(self, name ):
		mod = self.__module
		if hasattr( mod, name ): return getattr( mod, name )
		elif hasattr( mod, self.__name+name ): return getattr( mod, self.__name+name )
		else:
			for prefix in self.__try_names:
				if hasattr( mod, prefix+name ): return getattr( mod, prefix+name )
			if self.__secondary: return getattr( self.__secondary, name )
			else: raise AttributeError

def module( name, space=None, mode='ctypes', platform='', secondary=None, fold_constants=False ):
	mod = load( name, mode, platform )
	if fold_constants: mod.hettinger_transform()
	if mod:
		if type(space) is dict:
			for n in dir(mod):
				if not n.startswith('__'): space[ n ] = getattr(mod,n)
		return ModuleWrapper( name, mod, secondary )

########### Wrapper API ############

CTYPES_FOOTER = ''
def wrap( name, header=None, insert_headers=[], library=None, defines=[], undefines=[], includes=[], ctypes=True, rffi=True, cplusplus=False, platform='', system_include=None, ctypes_footer='' ):
	global LIBS, CTYPES_OUTPUT, RFFI_OUTPUT, INCLUDE_DIRS, SYS_INCLUDE_DIRS, MACRO_DEFS, MACRO_UNDEFS, INSERT_HEADERS, CTYPES_FOOTER

	_reset_wrapper_state()
	LIBS = []
	INCLUDE_DIRS = list(includes)		# copy since we modify it
	INSERT_HEADERS = list( insert_headers )
	SYS_INCLUDE_DIRS = []
	CTYPES_FOOTER = ctypes_footer

	if system_include:
		SYS_INCLUDE_DIRS.append( system_include )
		INCLUDE_DIRS.append( system_include )
		for n in os.listdir( system_include ):
			if n=='linux':		# for stddef.h
				sub = os.path.join( system_include, n )
				if sub not in INCLUDE_DIRS: INCLUDE_DIRS.append( sub )

	if not library:
		libname = '%s.so' %name
		if not libname.startswith('lib'): libname = 'lib'+libname
		guess1 = os.path.join( '/usr/local/lib', libname )
		guess2 = os.path.join( '/usr/lib', libname )
		if os.path.isfile( guess1 ): library = guess1
		elif os.path.isfile( guess2 ): library = guess2


	if library: LIBS.append( library )
	#for d in defines: MACRO_DEFS.append( d )
	MACRO_DEFS = list( defines )
	MACRO_UNDEFS = list( undefines )

	if ctypes:
		pre = os.path.join( 'genctypes'+platform, name )
		mdir = os.path.join( CACHEDIR, pre )
		if not os.path.isdir( mdir ):
			os.makedirs( mdir )
			open( os.path.join(os.path.join(CACHEDIR,'genctypes'+platform),'__init__.py'), 'wb' )
		CTYPES_OUTPUT = os.path.join(pre,'__init__.py')

	if rffi:
		pre = os.path.join( 'genrffi'+platform, name )
		mdir = os.path.join( CACHEDIR, pre )
		if not os.path.isdir( mdir ):
			os.makedirs( mdir )
			open( os.path.join(os.path.join(CACHEDIR,'genrffi'+platform),'__init__.py'), 'wb' )
		RFFI_OUTPUT = os.path.join(pre,'__init__.py')

	if cplusplus: a = CPlusPlus( header )
	else: a = C( header )
	a.save()
	if not platform:
		return _load( name, 'ctypes' )



#################################################################
INSERT_HEADERS = []	# for fixing bad headers, or combine multiple headers into one
HEADERS = []		# DEPRECATE TODO
INCLUDE_DIRS = []
MACRO_DEFS = []
MACRO_UNDEFS = []
LIB_NAME = ''	# not used?
LIB_PATH = ''	# not used?
LIB = ''		# ctypes header
FAKE_LIBC = None
LIBS = []
SYS_INCLUDE_DIRS = []
CTYPES_OUTPUT = None
RFFI_OUTPUT = None

CONFIG = {
	'include_dirs'	: INCLUDE_DIRS,
	'link_libs'		: LIBS,
	'extra_headers'	: HEADERS,
}


def translate_rpython( func, inline=True, compile=False, stackless=False, gc='ref', functions=[] ):
	from pypy.translator.interactive import Translation
	if stackless: assert gc != 'ref'	# this can go away later when pypy supports stackless+ref
	# other gc types: 'ref', 'framework', 'framework+asmgcroot', 'hybrid'

	t = Translation( func, standalone=True, inline=inline, gc=gc, stackless=stackless)

	t.driver.secondary_entrypoints = functions
	print( 'secondary entry points', t.driver.secondary_entrypoints )

	print('-'*80); print('#### PYPY FLOWGRAPH STEP1 COMPLETE ####'); print('-'*80)
	t.annotate()
	print('-'*80); print('#### PYPY ANNONTATION STEP2 COMPLETE ####'); print('-'*80)
	#print( 'ann_argtypes', t.ann_argtypes )
	args = [int]	# force int makes standalone compatible, main must return int
	t.rtype( None )	#interactive.py", line 66, in ensure_setup raise Exception("inconsistent argtype supplied")
	print('-'*80); print('#### PYPY RTYPER STEP3 COMPLETE ####'); print('-'*80)

	predeclare = ''
	t.source_c(); print('-'*80); print('#### PYPY SOURCE GENERATION STEP4 COMPLETE ####'); print('-'*80)
	headers = []
	sources = []
	## copy generated source to our jni directory ##
	for f in t.driver.cbuilder.targetdir.listdir():		# after source_c is called this is available
		if f.ext == '.h': headers.append( f )
		elif f.ext == '.c': sources.append( f )
	for f in t.driver.cbuilder.extrafiles:
		if f not in sources: sources.append( f )	# module_cache/module_#.c

	if compile: return t.compile_c()
	else: return headers, sources

# just for testing #####################
def test_rpy(x):
	a = 'helloworld'
	print( a )
	b = ['a','b']
	for i in b: print( i )	# <PtrRepr * Array of Char >
	for j in ['hello', 'world']: print( j )
	c = 1 + 99
	print( c  )
	return 1	#Exception: stand-alone program entry point must return an int (and not, e.g., None or always raise an exception)




def scan_cmake( url ):
	cwd = os.getcwd()
	path,cmake = os.path.split(url)
	data = open(url,'rb').read()
	os.chdir( path )
	do = False
	paths = []
	ifdefs = {}
	prevline = None
	debug = ''
	for line in data.splitlines():
		line = line.strip()
		if not line: continue	# skip whitespace
		debug += line + '\n'
		if line.startswith( 'INCLUDE_DIRECTORIES(' ):
			if do: raise SyntaxError
			do = True
			line = line.replace('INCLUDE_DIRECTORIES(', '')	# expects single per line
		if do:
			if ')' in line: do = False; line = line.replace(')','')
			for chk in line.split():
				if '$' in chk: print( 'warning: can not parse $ syntax ->', chk )
				elif os.path.isdir( chk ):
					p = os.path.abspath( chk )
					if prevline:
						if prevline.startswith('IF('):
							ifdef = prevline.split('IF(')[-1].split(')')[0].strip()
							print( 'looks like a IF def macro ->', ifdef )
							#if ifdef not in ifdefs: ifdefs[ ifdef ] = []
							#if p not in ifdefs[ ifdef ]: ifdefs[ ifdef ].append( p )
							ifdefs[ ifdef ] = p
						elif p not in paths: paths.append( p )
					elif p not in paths: paths.append( p )
				else: print( debug); raise SyntaxError
		prevline = line

	os.chdir(cwd)
	#print paths
	#print ifdefs
	return {'includes': paths, 'ifdefs':ifdefs }


def find_header_directory( name, path='.' ):
	if name in os.listdir( path ): return path
	for p in INCLUDE_DIRS:
		if name in os.listdir( p ): return p

	if '--scan-cmake' in sys.argv and 'CMakeLists.txt' in os.listdir( path ):
		cmake = scan_cmake( os.path.join( path, 'CMakeLists.txt' ) )
		for p in cmake['includes']:
			if name in os.listdir( p ): return p
		for macro in MACRO_DEFS:
			if macro in cmake['ifdefs']:
				p = cmake['ifdefs'][macro]
				if name in os.listdir( p ): return p
		if cmake['ifdefs']:
			for macro in cmake['ifdefs']:
				print( 'warning: using undefined macro name:', macro )
				p = cmake['ifdefs'][macro]
				if name in os.listdir( p ): return p

	if '/' in name:		# bug fix dec5th, sometimes headers have path/name/header.h
		a,b = os.path.split( name )
		if b in os.listdir( path ): return path
		for p in INCLUDE_DIRS:
			if b in os.listdir( p ): return p


	print( 'warning: resorting to final hacks to find headers' )
	for n in os.listdir( path ):	# check subdirs
		a = os.path.join( path, n )
		if os.path.isdir( a ) and not n.startswith('.'):
			if name in os.listdir( a ): return a

	## check one directory up, then subs
	a,b = os.path.split( path )
	if name in os.listdir(a): return a
	for n in os.listdir( a ):
		c = os.path.join( a, n )
		if c != path and os.path.isdir(c) and not n.startswith('.'):
			if name in os.listdir( c ): return c

	print( 'error: failed to find header ->', name )



def isclass( ob, *names ):
	cname = ob.__class__.__name__
	for name in names:
		if cname == name: return True



b7 = bug = b2=None
odebug = None

def _reset_wrapper_state():
	SomeThing.Structs.clear()
	SomeThing.Unions.clear()
	SomeThing.Functions.clear()
	SomeThing.Enums.clear()
	SomeThing.SomeThings.clear()
	SomeThing.Arrays.clear()

	SomeThing.Nodes = []
	SomeThing.MACRO_GLOBALS.clear()
	SomeThing.Types.clear()
	SomeThing.Typedefs.clear()
	SomeThing.EnumTypes.clear()


class SomeThing(object):
	'''
	ID, Constant, Typename, Decl, or any subtype of Decl:
		TypeDecl
		PtrDecl
			[ subtypes ]
	'''
	Structs = {}
	Unions = {}
	Functions = {}
	Enums = {}
	SomeThings = {}
	Arrays = {}

	Nodes = []
	MACRO_GLOBALS = {}	# TODO, is there a better way to deal with this?


	@staticmethod
	def sort( things ):
		for parent in things:
			pidx = things.index( parent )
			for child in parent.fields:
				type = child.type()
				if type.startswith('struct:') or type.startswith('union:'):
					if child.cyclic: continue#; print('skipping cyclic', type); 	# ctypes
					name = type.split(':')[-1]
					#print('searching', name)
					found = False
					for cidx,c in enumerate( things ):
						if c._name() == name:
							found = True
							if cidx > pidx:
								print('--sort--', name, cidx, pidx)
								things.remove( c )
								things.insert( pidx, c )
								return True
					if not found: print('not found', name)

	@staticmethod
	def get_unions_and_structs(sort=False):
		valid = SomeThing.Unions.values() + SomeThing.Structs.values()
		r = []
		for node in SomeThing.Nodes:
			if node in valid: r.append( node )
		if not sort: return r
		else:
			i = 0
			while sort and i < 400:
				sort = SomeThing.sort( r )
				i += 1
			print( 'sorts', i )
			return r


	@staticmethod
	def get_enums():
		r = []; a = SomeThing.Enums.values(); a.sort()
		for e in a:
			if e not in r: r.append( e )
		return r

	@staticmethod
	def get_unions(): return SomeThing.Unions.values(); a.sort()
	@staticmethod
	def get_structs(): return SomeThing.Structs.values(); a.sort()

	@staticmethod
	def depsort( a ):
		sorts = 0
		for x in a:
			if x.dependson and x.dependson in a:
				if a.index( x ) > a.index( x.dependson ):
					sorts += 1
					a.remove( x )
					print( 'depsorting', x )
					a.insert( a.index(x.dependson)-1, x )
		return sorts

	@staticmethod
	def get_funcs():
		r = []; a = SomeThing.Functions.values(); a.sort()
		for e in a:
			if e not in r:
				if e.name() not in SomeThing.Structs:	# may16th 2011
					r.append( e )
		return r

	def get_ancestors(self, ancest=None):
		if ancest is None: ancest = []
		if self.parent:
			ancest.append( self.parent )
			return self.parent.get_ancestors( ancest )
		else: return ancest

	PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert'.split()

	ReservedNames = 'id object type enumerate isinstance len globals locals tuple dict list int float str bool getattr setattr hasattr range None self'.split() + PYTHON_RESERVED_KEYWORDS
	def name(self):	# note: Decl can have a .name but it can be None, decl.type.name should then have the real name
		if hasattr(self.ast, 'name' ) and self.ast.name:
			if self.ast.name in SomeThing.ReservedNames: return 'C_%s' %self.ast.name
			else: return self.ast.name
		elif hasattr(self.ast, 'declname') and self.ast.declname:
			if self.ast.declname in SomeThing.ReservedNames: return 'C_%s' %self.ast.declname
			else: return self.ast.declname
		elif self.child: return self.child.name()

	def gen_rffi(self, declare=False):
		if self.child and self.child.name(): return self.child.gen_rffi( declare )
		elif self.tag == 'TypeDecl': return '#%s							<TypeDecl=%s>' %(self.name(),self.type())
		else: return '#%s							<ast=%s>' %(self.name(),self.tag)
	def gen_ctypes(self, declare=False):
		if self.child and self.child.name(): return self.child.gen_ctypes( declare )
		elif self.tag == 'TypeDecl': return '#%s							<TypeDecl=%s>' %(self.name(),self.type())
		else: return '#%s							<ast=%s>' %(self.name(),self.tag)

	def gen_python(self):
		if self.child and self.child.name(): return self.child.gen_python()
		else: return ['#%s							<ast=%s>' %(self.name(),self.tag) ]

	@classmethod
	def get_node_by_name( self, name ):
		for n in self.Nodes:
			if n.name() == name: return n

	Types = {}
	Typedefs = {}
	EnumTypes = {}	# typedef'ed enums are different?
	def setup( self ): pass		# overloaded

	def __init__(self, ast, parent=None ):
		SomeThing.Nodes.append( self )
		self.cyclic = False		# for structs and unions
		self.ast = ast
		self.tag = ast.__class__.__name__
		self.parent = parent
		self.array = None		# pass the array down the tree
		if parent:
			## TODO, is this required?
			if isclass( parent, 'Array' ): self.array = parent
			elif parent.array: self.array = parent.array
			elif parent.parent and isclass( parent.parent, 'Array' ):
				self.array = parent.parent
			elif parent.parent and parent.parent.array:
				self.array = parent.parent.array

		self.pointer = isclass( ast, 'PtrDecl' )
		self.child = None
		child = None
		if hasattr( ast, 'type' ): child = ast.type

		if child:
			if isclass( child, 'Struct' ):		self.child = Struct( child, parent=self )
			elif isclass( child, 'Union' ):		self.child = Union( child, parent=self )
			elif isclass( child, 'FuncDef', 'FuncDecl' ): self.child = Function( child, parent=self )
			elif isclass( child, 'Enum' ): self.child = Enum( child, parent=self )
			elif isclass( child, 'ArrayDecl'):	#, 'ArrayRef' ):
				child.show()
				self.child = Array( child, parent=self )
				if self.tag == 'Typedef': self.array = self.child	#TODO revisit
				elif self.tag == 'Decl': self.array = self.child	# structs that contain arrays - may5th

			else:	self.child = SomeThing( child, parent=self )

		if self.tag == 'Typedef':
			#print( 'Typedef: %s' %ast.name )
			#ast.show()
			if ast.name in SomeThing.Typedefs:
				#print( SomeThing.Typedefs.keys())
				print( '---------- warning duplicate typedef ----------' )
				print( ast.name )
				ast.show()
				#raise SyntaxError
			SomeThing.Typedefs[ ast.name ] = self

		if self.tag == 'TypeDecl':
			if isclass( ast.type, 'IdentifierType' ):
				if not ast.type.names: ast.show()
				else: SomeThing.Types[ ast.declname ] = ' '.join( ast.type.names )	# fixed may5th
			elif isclass( ast.type, 'Struct', 'Union' ):
				SomeThing.Types[ ast.declname ] = self.child
			elif isclass( ast.type, 'Enum' ):
				SomeThing.EnumTypes[ ast.declname ] = self.child
			else:
				print('TODO - non ident types'); ast.show()

		ancest = self.get_ancestors()
		self.dependson = None
		for p in ancest:
			if isclass( p, 'Struct', 'Union' ):
				self.dependson = p
				break

		self.setup()
		self.unnamed = False
		name = self.name()
		if not self.parent and name is None:
			self.unnamed = True
			if self.child and self.child.tag != 'Enum':
				raise

		if not name and self.parent:		# fixes nested struct problem
			name = self.parent.name()
		if name:
			a = getattr( SomeThing, self.__class__.__name__+'s' )
			if name in a:
				other = a[name]
				if self.ast.__class__.__name__.endswith('Decl'): pass
				elif other.ast.__class__.__name__.endswith('Decl'): a[name] = self
				else: a[ name ] = self.resolve_conflict( other )
			else: a[ name ] = self



	def num_ast_nodes( self ): return len(self.flatten_ast_nodes( self.ast ) )
	def flatten_ast_nodes( self, ast, nodes=None ):
		if nodes is None: nodes = []
		nodes.append( ast )
		children = ast.children()
		if children: [self.flatten_ast_nodes( child, nodes ) for child in children ]
		return nodes
		
	def resolve_conflict( self, other ):		# the one with more ast nodes is the one we want rule, never breaks?
		if self.num_ast_nodes() > other.num_ast_nodes(): return self
		else: return other

	def pointers( self, p=None ):		# p=[]		bad idea
		if p is None: p = []		# prevents memleak
		if self.pointer: p.append( self )
		if self.child: return self.child.pointers( p )
		else: return p


	def rffi_type( self ):
		type = self.type()
		typedef = self.typedef()
		pointers = len(self.pointers())
		array = 0
		if self.array: array += self.array.length()
		if typedef:
			pointers += len( typedef.pointers() )
			if typedef.array: array += typedef.array.length()

		ctype = None

		if ':' in type:
			if type.startswith('union:') or type.startswith('struct:'):
				if not self.name(): ctype = 'rffi.VOIDP'	# opaque, un-named union or struct
				else: a,ctype = type.split(':')
			elif type.startswith('enum:'): ctype = 'rffi.INT'
			elif type.startswith('function:'):
				if typedef and typedef.name() in SomeThing.Functions and 0:
					ctype = SomeThing.Functions[typedef.name()].gen_ctypes_funcdef()
				else: ctype = 'rffi.VOIDP'

		else:
			_type = type.split()
			if 'unsigned' in _type:
				unsigned = 'U'
				_type.remove( 'unsigned' )
			else: unsigned = ''
			if 'signed' in _type:
				assert not unsigned
				_type.remove( 'signed' )

			if _type.count( 'long' ) == 2: ctype = 'rffi.%sLONGLONG' %unsigned
			elif 'double' in _type and 'long' in _type: ctype = 'rffi.LONGDOUBLE'
			elif 'int' in _type and 'short' in _type: ctype = 'rffi.%sSHORT' %unsigned
			elif 'int' in _type and 'long' in _type: ctype = 'rffi.%sLONG' %unsigned
			else:
				if len(_type) != 1:
					self.ast.show()
					print( 'WARN: this should never happen', _type )
					_type = ['void']
				type = _type[0]
				if type == 'void': ctype = 'rffi.VOIDP'
				elif type == 'size_t': ctype = 'rffi.SIZE_T'
				elif type == 'ssize_t': ctype = 'rffi.SSIZE_T'
				else:
					ctype = 'rffi.%s%s'%(unsigned,type.upper())


		if not ctype:
			self.ast.show()
			if self.type() == '<unknown-type>':
				ctype = 'rffi.VOIDP'; print('TODO FIXME')
			else:
				print( self.type() )
				raise NotImplemented

		## special case void
		if type == 'void':
			if pointers: ctype = 'rffi.VOIDP'
			else: ctype = 'lltype.Void'
		else:
			if array:
				ctype = 'rffi.CFixedArray( %s, %s )' %( ctype, array )
				#pointers -= 1	# is this correct?
			if pointers > 0:
				#ctype = 'rffi.Ptr('
				_a = 'rffi.CArrayPtr(' * pointers
				_a += ctype
				ctype = _a + ( ')'*pointers )

		return ctype


	#Usually, ctypes does strict type checking. This means, if you have POINTER(c_int) in the argtypes list of a function or as the type of a member field in a structure definition, only instances of exactly the same type are accepted. There are some exceptions to this rule, where ctypes accepts other objects. For example, you can pass compatible array instances instead of pointer types. So, for POINTER(c_int), ctypes accepts an array of c_int: - from the ctypes tutorial
	def ctypes_type( self ):		# TODO array for all types
		type = self.type()
		typedef = self.typedef()
		pointers = len(self.pointers())
		array = 0
		if self.array:
			print( 'array item name', self.name() )
			array += self.array.length()
		if typedef:
			pointers += len( typedef.pointers() )
			if typedef.array: array += typedef.array.length()

		ctype = None

		if ':' in type:
			if type.startswith('union:') or type.startswith('struct:'):
				if not self.name(): ctype = 'ctypes.c_void_p'	# opaque, un-named union or struct
				else: a,ctype = type.split(':')
			elif type.startswith('enum:'): ctype = 'ctypes.c_int'
			elif type.startswith('function:'):
				pointers -= 1		# it is funny how ctypes deals with callback functions, or is this only true with typedef'ed functions?
				if typedef and typedef.name() in SomeThing.Functions:
					ctype = SomeThing.Functions[typedef.name()].gen_ctypes_funcdef()
				else: ctype = 'ctypes.c_void_p'

		else:
			_type = type.split()
			if 'unsigned' in _type:
				unsigned = 'u'
				_type.remove( 'unsigned' )
			else: unsigned = ''
			if 'signed' in _type:
				assert not unsigned
				_type.remove( 'signed' )

			if _type.count( 'long' ) == 2: ctype = 'ctypes.c_%slonglong' %unsigned
			elif 'double' in _type and 'long' in _type: ctype = 'ctypes.c_longdouble'
			elif 'int' in _type and 'short' in _type: ctype = 'ctypes.c_%sint16' %unsigned	# correct?
			elif 'int' in _type and 'long' in _type: ctype = 'ctypes.c_%sint64' %unsigned	# correct?
			else:
				if len(_type) != 1:
					self.ast.show()
					print( 'WARN: this should never happen', _type )
					_type = ['void']

				type = _type[0]
				if type == 'void': ctype = 'ctypes.c_void_p'
				elif type == 'size_t': ctype = 'ctypes.c_size_t'
				elif type == 'ssize_t': ctype = 'ctypes.c_ssize_t'
				elif type == 'char' and unsigned: ctype = 'ctypes.c_ubyte'
				elif hasattr( ctypes, 'c_%s%s'%(unsigned,type) ):
					ctype = 'ctypes.c_%s%s'%(unsigned,type)		# should catch most types, even int16
				else:
					if type == 'uchar': ctype = 'ctypes.c_ubyte'
					else:
						print( 'WARN - bad type:', _type )
						raise NotImplemented

		if not ctype:
			self.ast.show()
			if self.type() == '<unknown-type>':
				ctype = 'ctypes.c_void_p'; print('TODO FIXME')
			else:
				print( self.type() )
				raise NotImplemented

		if array:		# most of the time its an array that may have pointers to it, not an array of pointers.
			ctype = '( %s * %s )' %( ctype, array )
		if pointers > 0:
			_a = 'ctypes.POINTER(' * pointers
			_a += ctype
			ctype = _a + ( ')'*pointers )

		return ctype


	def typedef( self ):
		if isclass( self.ast, 'IdentifierType' ):
			if self.ast.names:
				#name = self.ast.names[0]		# found bug may4th
				name = ' '.join( self.ast.names )
				if name in SomeThing.Typedefs: return SomeThing.Typedefs[ name ]
		elif self.child: return self.child.typedef()

	TYPEDEF_HACKS = {
		'int8_t'		:	'int8',
		'uint8_t'	:	'uint8',
		'int16_t'	:	'int16',
		'uint16_t'	:	'uint16',
		'int32_t'	:	'int32',
		'uint32_t'	:	'uint32',
		'int64_t'	:	'int64',
		'uint64_t'	:	'uint64',
	}
	def type(self):
		if isclass( self.ast, 'IdentifierType' ):
			if not self.ast.names: return '<unknown-type>'
			name = ' '.join(self.ast.names)
			#if name in SomeThing.Types: return SomeThing.Types[ name ].type()
			if name in SomeThing.Typedefs:
				#print( 'lookup typedef', name)
				# is this a bug in pycparser? see SDL_JoystickGetAxis - thinks its an int
				if name in self.TYPEDEF_HACKS:
					return self.TYPEDEF_HACKS[ name ]
				else:
					typedef = SomeThing.Typedefs[ name ]
					#print( typedef )
					#typedef.ast.show()
					return typedef.type()

			elif name in SomeThing.Types:	# is this safe, is it even used?
				_type = SomeThing.Types[ name ]
				if type(_type) is str: return _type
				else: return _type.type()

			elif name in SomeThing.MACRO_GLOBALS:
				#print( 'lookup macro global', name )
				type(SomeThing.MACRO_GLOBALS[ name ])
			elif name: return name
			else:
				self.ast.show(); print( self )
				raise SyntaxError
		elif isclass( self.ast, 'FuncDecl' ): return 'function:%s'	%self.name()
		elif isclass( self.ast, 'Struct', 'Union' ):
			n = self.name()
			if not n and self.parent: n = self.parent.name()		# nested problem
			if isclass( self.ast, 'Struct' ): return 'struct:%s'	%n
			else: return 'union:%s'	%n
		elif isclass( self.ast, 'Enum' ): return 'enum:%s' %self.name()
		elif self.child: return self.child.type()
		else: return '<unknown-type>'

################### end SomeThing ###############


class Array( SomeThing ):
	def length( self ):
		if self.ast.dim:
			val = self.ast.dim
			if isclass( val, 'Constant' ): return int(val.value)
			elif isclass( val, 'BinaryOp' ):
				r = Enum.compute_binaryop( val )
				if r is None:
					print( 'WARNING, can not find length of array' )
					self.ast.show()
					return 0
				else: return r
			elif isclass( val, 'ID' ):
				e = Enum.search_for_enum_with_key( val.name )
				if e: return e.values_by_key[ val.name ]
			else:
				print('-------------------')
				self.ast.show()
				raise NotImplementedError
		else:
			# zero length case
			return 0


class Enum( SomeThing ):		# an enum can be nameless
	@staticmethod
	def get_enum_value( name ): return SomeThing.Enums[ name ].enum_value( name )

	@staticmethod
	def search_for_enum_with_key( key ):
		for name in SomeThing.Enums:
			if key in SomeThing.Enums[name].values_by_key:
				return SomeThing.Enums[name]

	@staticmethod
	def compute_binaryop( binop ):
		#print binop.show()
		left = right = None
		if isclass( binop.right, 'Constant' ): right = int( binop.right.value, 16 )
		elif isclass( binop.right, 'ID' ): right = Enum.get_enum_value( binop.right.name )
		elif isclass( binop.right, 'BinaryOp' ): right = Enum.compute_binaryop( binop.right )

		if isclass( binop.left, 'Constant' ): left = int( binop.left.value, 16)
		elif isclass( binop.left, 'ID' ): left = Enum.get_enum_value( binop.left.name )
		elif isclass( binop.left, 'BinaryOp' ): left = Enum.compute_binaryop( binop.left )

		if left is not None and right is not None:
			e = '%s %s %s' %(left, binop.op, right)
			return eval( e )
		else:
			print('TODO unsupported binop:', binop)

	def enum_value( self, key ): return self.values_by_key[ key ]

	def _parse_constant( self, const ):
		value = const.value.strip()
		if const.type in 'int long'.split():
			if value.startswith('0x'):
				try: return int(value, 16)
				except: return int( value, 34 )	# base 2-36, is '0x0FFFFFFFU' base 34?

			elif value.endswith('U'): return int(value[:-1])	# what is ending with U?
			else: return int( value )
		elif const.type in 'float double'.split():
			if value.lower().endswith('f'): value = value[:-1]
			return float( value )
		elif value.startswith('"') or value.startswith("'"): return value[1:-1]
		else:
			print( const)
			print( const.type)
			print( const.value)
			raise NotImplementedError

	def setup(self):
		self.values = []
		self.values_by_key = {}
		if isclass( self.parent, 'FuncDef', 'FuncDecl' ) or not self.ast.values:
			self.ast.show()
			return
		self.ast.show()

		i = 0
		for val in self.ast.values.children():
			if val.value:
				print( val.value )
				if isclass( val.value, 'Constant' ):
					i = self._parse_constant( val.value )
				elif isclass( val.value, 'BinaryOp' ):
					i = self.compute_binaryop( val.value )
				elif isclass( val.value, 'UnaryOp' ):
					#print( dir(val.value) )
					#print( 'op', val.value.op, dir(val.value.op) )
					if isclass( val.value.expr, 'Constant' ):
						e = self._parse_constant( val.value.expr )
						i = eval( '%s %s' %(val.value.op,e) )
					elif isclass( val.value.expr, 'BinaryOp' ):
						i = self.compute_binaryop( val.value.expr )
					else:
						print( val.value.expr )
						raise NotImplementedError
				elif isclass( val.value, 'ID' ):
					print( dir(val.value) )
					if val.value.name in self.values_by_key: i = self.values_by_key[ val.value.name ]
					else:
						other = self.search_for_enum_with_key( val.value.name )
						if other:		# enums that reference other enums
							i = other.values_by_key[ val.value.name ]
						else:
							print( '--WARN enum not found--' ); val.show()
							raise NotImplementedError

				elif isclass( val.value, 'TernaryOp' ):
					print( 'TODO' ); val.show()
					#print( val.value )

				else:
					print('--unknown enum type--')
					print( 'TODO' ); val.show()
					print( val.value )
					raise NotImplementedError

			Enum.Enums[ val.name ] = self		# TODO raise if val.name already in Enums?
			self.values.append( (val.name, i) )
			self.values_by_key[ val.name ] = i
			#if not val.value:
			if type(i) == int: i += 1
			else: print( 'TODO non int incrementing enum')
			#if self.name() == 'WIIUSE_EVENT_TYPE': assert 0

	def gen_rffi(self, declare=False): return self._gen()
	def gen_ctypes(self, declare=False): return self._gen()
	def gen_rpython(self, declare=False): return self._gen().splitlines()

	def is_named_enum(self): return self.name()	# simple enum globals, or dict wrapped enum

	def _gen(self):
		r = ''
		if self.is_named_enum():	# wrap in dict
			n = self.name()
			if n.startswith('_') and n[1:] not in self.ReservedNames: n = n[1:]
			r = '%s = { \n' %n
			for v in self.values:
				name,value = v
				if type(value) is str: r += '\t"%s" : "%s", \n' %(name,value.replace('"', "'"))
				else: r += '\t"%s" : %s, \n' %(name,value)
			r += '}\n'
		else:			# define as simple globals
			for v in self.values:
				name,value = v
				if name.startswith('_') and name[1:] not in self.ReservedNames: name = name[1:]
				if type(value) is str: r += '%s = "%s" \n' %(name,value.replace('"', "'"))
				else: r += '%s = %s \n' %(name,value)
		return r

	def dict_format(self):
		r = ''
		for v in self.values:
			name,value = v
			if name.startswith('_') and name[1:] not in self.ReservedNames: name = name[1:]
			if type(value) is str: r += ' "%s" : "%s", ' %(name,value.replace('"', "'"))
			else: r += ' "%s" : %s, ' %(name,value)
		return r


class Function( SomeThing ):

	def setup(self):
		ast = self.ast
		#ast.show()
		#print 'function', ast.coord.file, ast.coord.line
		self.returns = None
		self.args = []
		self.body = None
		self.static = False
		args = None
		if isclass( self.ast, 'FuncDecl' ):
			decl = self.ast
			if ast.args: args = ast.args

		elif isclass( self.ast, 'FuncDef' ):
			decl = self.ast.decl
			#print( dir(decl) )
			if decl.storage and 'static' in decl.storage: self.static = True
			self.child = SomeThing( decl, parent=self )	# do not create sub-func type
			if decl.type.args: args = decl.type.args
			## TODO body
			if ast.body.block_items:
				self.body = True
				for node in ast.body.block_items:
					if isclass( node, 'Return' ): pass

		if args:
			for arg in args.children():
				if isclass( arg, 'EllipsisParam' ): pass #print 'EllipsisParam'	#TODO 
				else: self.args.append( SomeThing(arg, parent=self) )

		self.returns = SomeThing( decl.type, parent=self )		# re-enabled may16th
		#print( '-----------function---------', self.name() )
		#decl.show()
		#if isclass( decl.type, 'TypeDecl', 'PtrDecl' ):
		#	self.returns = SomeThing( decl.type.type, parent=self )
		#else:
		#	self.returns = SomeThing( decl.type, parent=self )
		#	#print('returns', decl.type)
		#print('----')
		#decl.type.show()
		#print('---------------------------')

		#if self.name() == 'SDL_JoystickGetAxis':		# ohno!
		#	self.ast.show()
		#	print( self.returns.type() )
		#	assert 0

	def gen_rffi( self, declare=False ):
		args = ''; name = self.name()
		if len(self.args)==1 and self.args[0].type() == 'void': pass
		else:
			for item in self.args: args += '%s,' %item.rffi_type()
		_type = self.returns.type()
		if ':' in _type:
			#res = 'lltype.Ptr(%s)' %res	#lltype.py", line 455, in __init__ raise TypeError, "function result can only be primitive or pointer"
			res = '%sPOINTER' %_type.split(':')[-1]
		else:
			res = self.returns.rffi_type()

		return '%s = _c_external_function( "%s", [%s], %s )' %(name, name, args, res)

	def gen_ctypes_funcdef( self ):		# always redeclare func signature
		r = 'ctypes.CFUNCTYPE(%s, ' %self.returns.ctypes_type()
		if not (len(self.args)==1 and self.args[0].type() == 'void'):
			for item in self.args: r += '%s,' %item.ctypes_type()
		return r + ')'

	def gen_ctypes( self, prototype=False ):
		name = self.name()
		if prototype:
			for arg in self.args:
				#assert arg.type() != '<unknown-type>'
				if arg.type() == '<unknown-type>':
					print( 'WARNING - bad function arg:', name )
					print( 'arg name: ', arg.name() )
					assert 0
			return 'PROTOTYPE_%s = %s' %(name, self.gen_ctypes_funcdef())

			if 0:
				s = 'PROTOTYPE_%s = ctypes.CFUNCTYPE(' %name
				if self.returns.type().startswith('function:'):	# bug fixed april 15th
					s += ' %s, ' %(self.returns.gen_ctypes(True))
				else: s += ' %s, ' %self.returns.ctypes_type()

				if len(self.args)==1 and self.args[0].type() == 'void': pass
				else:
					for item in self.args:
						if item.type().startswith('function:'):	# fixed april 15th
							s += '%s, ' %(item.gen_ctypes(True).split('=')[-1])
						else: s += '%s, ' %item.ctypes_type()
				return s + ')'


		elif self.static: return '# static function: %s'	%name
		else:
			args = ''
			if len(self.args)==1 and self.args[0].type() == 'void':
				if self.args[0].name(): args = '("%s",		ctypes.c_void_p)' %self.args[0].name()

			else:
				for item in self.args:
					_n = str(item.name())	# can return None
					_n = _n.replace('None', 'none')
					args += '\n\t("%s",		%s),' %(_n, item.ctypes_type())
			restype = self.returns.ctypes_type()
			return '%s = _rpythonic_function_(\t\t"%s", %s, [%s] )\n' %(name, name, restype, args )

	def gen_python( self ):
		if self.body:
			args = ''; name = self.name()
			if len(self.args)==1 and self.args[0].type() == 'void': pass
			else:
				for item in self.args: args += '%s,' %item.name()
			return [ 'def %s( %s ): pass' %(name,args) ]
		else: return []

ubug = None
class Union( SomeThing ):
	@staticmethod
	def mark_cyclic():
		r = []
		things = SomeThing.get_unions_and_structs()
		for p in things:
			for sub in p.substructures():
				for c in things:
					if c._name() == sub.type().split(':')[-1]:
						if c.contains_struct( p.type().split(':')[-1] ):
							sub.cyclic = True; r.append( c )
							print( 'found cyclic member', sub.name() )
						break
		return r

	def setup(self):
		ast = self.ast
		ast.show()
		self.fields = []
		self.forwardref = False
		self.contains_arrays = 0
		# SomeThing(a, parent=self) is this always safe with hacks like _name ?
		if ast.decls:
			self.fields = [ SomeThing(a, parent=self) for a in ast.decls ]
			for a in self.fields:
				if a.array: self.contains_arrays += 1

		else: self.forwardref = True

	def functions( self ):
		r = []
		for c in self.fields:
			type = c.type()
			if type.startswith('function:'): r.append( c )
		return r


	def substructures( self ):
		r = []
		for c in self.fields:
			type = c.type()
			if type.startswith('struct:') or type.startswith('union:'): r.append( c )
		return r

	def contains_struct( self, name ):
		for c in self.substructures():
			n = c.type().split(':')[-1]
			if n == name: return True
		return False


	def _name(self):		# fixes type def unions
		name = self.name()
		if not name and self.parent: name = self.parent.name()
		return name

	def gen_rffi( self, declare=False, forward=False, become=False ):		# no rffi.CUnion? in hints?
		name = self._name()
		if forward:
			return '%sPOINTER = lltype.Ptr(lltype.ForwardReference())' %name
		elif become:
			return '%sPOINTER.TO.become(%s)' %(name,name)
		elif declare: return '%s = rffi.CStruct( "%s" )' %(name,name)
		else:
			a = ''
			for item in self.fields:
				if item.name():
					a += '\n\t\t( "%s", \t\t%s ),' %(item.name(), item.rffi_type() )
			return '_def_cstruct( %s, %s \n)'	%( name, a )

	def gen_ctypes( self, declare=False ):
		name = self._name()
		#altname = None		# changed may19th
		#if name.startswith('_') and name[1:] not in self.ReservedNames: altname = name[1:]
		if declare:
			## can not declare and pass, must also define _fields_ and append items to it,
			## otherwise ctypes reports: AttributeError: _fields_ is final
			## but can not declare with _fields_=[] and then append to it later - must resort to sorting??
			if self.tag == 'Union': a = 'class %s(ctypes.Union): pass' %name
			else:
				if self.contains_arrays: a = 'class %s(_rpythonic_struct_): _array_wrapper_ = True' %name
				else: a = 'class %s(_rpythonic_struct_): pass' %name
			#if altname: a += '\n%s = %s' %(altname,name)
			return a
		else:
			a = ''
			for item in self.fields:
				if not item.name():
					a += '\n\t#opaque-warning# %s' %item
				else: a += '\n\t( "%s", %s ),' %(item.name(), item.ctypes_type() )
			#return '%s._fields_=[%s\n]\n' %(name, a)
			return '__freeze_rpythonic_struct( %s, [%s\n])\n' %(name, a)

	def gen_python( self, declare=False  ):
		global TT
		r = [ 'class %s(object):	# <%s>' %(self._name(),self.tag) ]
		r.append( '\tdef __init__(self):' )
		for item in self.fields:
			TT = item
			type = item.type()
			r.append( '\t\tself.%s = %s' %(item.name(),type) )
		return r
TT = None

class Struct( Union ):
	#def gen_rffi( self, declare=False ):
	#	a = ''; name = self._name()
	#	for item in self.fields: a += '( "%s", %s ),' %(item.name(), item.rffi_type() )
	#	return '%s = rffi.CStruct( "%s", %s )' %(name, name, a )
	pass


class SourceCode(object):
	def __init__(self, url, debug=False, platform=None):
		path,name = os.path.split(url)
		if path not in INCLUDE_DIRS: INCLUDE_DIRS.append( path )
		self.source_url = url
		self.source_path, self.source_file = os.path.split( url )
		self.platform = platform

		## try to find compiled shared lib
		self.shared_library = None

		if LIBS: self.shared_library_name = os.path.splitext( os.path.split(LIBS[-1])[-1] )[0]
		else:
			if sys.platform.startswith('linux'):	# this only works in basic cases
				libname = os.path.splitext( self.source_file )[0] + '.so'
				if not libname.startswith('lib'): libname = 'lib' + libname
				guess1 = os.path.join( self.source_path, libname )
				guess2 = os.path.join( '/usr/local/lib', libname )
				guess3 = os.path.join( '/usr/lib', libname )
				if os.path.isfile( guess1 ): self.shared_library = guess1		# rare case
				elif os.path.isfile( guess2 ): self.shared_library = guess2	# user installed
				elif os.path.isfile( guess3 ): self.shared_library = guess3	# system
			if self.shared_library and self.shared_library not in LIBS: LIBS.append( self.shared_library )
			else: self.shared_library_name = '<undefined>'

		self.source_data = self.source_processed = open(url,'rb').read()
		self.headers = []
		self.includes = list( INCLUDE_DIRS )
		self.if_defs = []
		self.macro_globals = []
		self.macro_globals_values = {}
		## workaround
		SomeThing.MACRO_GLOBALS = self.macro_globals_values

		if '--no-preprocessor' not in sys.argv: self.source_processed = self.c_preprocessor()
		self.parse( self.source_processed, debug=debug )

	def save(self):
		#n = os.path.splitext(self.source_file)[0]
		#data = self.gen_python()		# TODO get this working
		#open('_python_%s.py'%n,'wb').write( data )
		if RFFI_OUTPUT:
			data = self.generate_rffi_wrapper()
			url = os.path.join( CACHEDIR, RFFI_OUTPUT )
			f = open(url,'wb'); f.write( data ); f.close()
			pprint('saved rffi wrapper: %s' %url, 2)
		if CTYPES_OUTPUT:
			print( 'saving ctypes wrapper: %s' %CTYPES_OUTPUT )
			data = self.generate_ctypes_wrapper()
			url = os.path.join( CACHEDIR, CTYPES_OUTPUT )
			f = open(url,'wb'); f.write( data ); f.close()
			pprint('saved ctypes wrapper: %s' %url, 2)

	def parse_macro( self, name, start, srclines ):
		if '(' in name or ')' in name: return False		# fixed april 15th
		if name == 'bool': return False						# fixed May3, openjpeg.h braindamage

		_clean = lambda line: line.split('/*')[0].split('//')[0].strip()
		n = start
		v = _clean( srclines[ n ] )
		while v.endswith('\\'):
			n += 1; v = v[:-1] + _clean( srclines[ n ] )
		line = v
		v = v.split()
		if name != v[1]:
			print( 'warn: function macro: %s' %name )
			print( line )
			return False
		if len(v) >=4:
			a = line.split('(')[-1]		# take last
			a = a.replace(')','')		# assume just closing pairs
			a = a.strip(); val = a
			try:
				val = eval( val )
				self.macro_globals.append( name )	# retain order
				self.macro_globals_values[ name ] = val
				return True
			except:
				print('HARD macro to parse:', line)

		elif len(v) >= 3:
			#print( 'saving', u )
			val = v[-1]
			val = val.split('(')[-1]
			if val.endswith(')'): val = val[:-1]
			if '.' in val and val.lower().endswith('f'): val = val[:-1]	# float litteral
			try:
				val = eval( val )
				self.macro_globals.append( name )	# retain order
				self.macro_globals_values[ name ] = val
				return True
			except:
				try:
					a = v[-1]; b = v[-2]
					if a in self.macro_globals_values:
						val = self.macro_globals_values[ a ]
						self.macro_globals.append( name )	# retain order
						self.macro_globals_values[ name ] = val
						return True
					elif a.count('(') == 1 and a.count(')') == 1:
						val = eval( a, self.macro_globals_values, self.macro_globals_values )
						self.macro_globals.append( name )	# retain order
						self.macro_globals_values[ name ] = val
						return True
					else: print( 'WARN: non trival macro', line ); return False

				except:
					pprint('WARNING: can not parse: %s'%name, 6)
					pprint( line, 1 )
					pprint('-'*80)
					return False
		else: pprint( 'not touching unused macro: %s' %name, 4 )


	def c_preprocessor( self, source_type=None ):
		source = self.source_data

		## insert extra headers ##
		if INSERT_HEADERS:
			insert = ''
			for header in INSERT_HEADERS:
				assert os.path.isfile( header )
				source += '\n' + open(header,'rb').read()

		all_includes = {}
		## first pass inspection, check includes, try to parse macros ##	
		for idx, line in enumerate(source.splitlines()):
			if line.startswith('#'):
				line = line[1:]
				line = line.split('//')[0]
				line = line.split('/*')[0]
				if line.startswith( 'define' ): self.parse_macro( line.split()[1], idx, source.splitlines() )	# march21,2011
				elif line.startswith('ifndef'): self.if_defs.append( line.split()[-1] )
				elif 'include' in line.split():
					name = line.split()[-1]
					if name.startswith('<') and name.endswith('>'):
						name = name.replace('<', '').replace('>','')
						all_includes[ name.split('/')[-1] ] = name
					else:
						name = name.replace('"', ''); all_includes[ name.split('/')[-1] ] = name
						path = find_header_directory( name, path=self.source_path )
						if path:
							if path not in self.includes: self.includes.append( path )
							if name not in self.headers: self.headers.append( name )
						else:
							print( 'WARNING: failed to find header directory', name )


		## post headers, just a hack to combine many headers ##
		#for header in HEADERS: source += '#include "%s"\n' %header			# TODO deprecate HEADERS

		## pre cpp - extra define hacks - why is this not working ##
		pre = [
			'#define const __const',
			'#define const __const__',
		]
		source = '\n'.join( pre ) + '\n' + source

		## always check for unused macro defines ##
		args = ['cpp']
		if self.__class__ == CPlusPlus:
			args.append( '-x' )
			args.append( 'c++' )
			#args.append( '-Ihacks/c++/' )
		args.append( '-Wunused-macros' )

		if '--no-gnu' in sys.argv: args +=  ['-U__GNUC__' ]

		## avoid using fake libc
		if FAKE_LIBC: args.append( '-I%s' %FAKE_LIBC )

		if SYS_INCLUDE_DIRS:
			#args += '-nostdinc -nostdinc++'.split()		# cpp prints some warning
			args.append( '-nostdinc' )

		for path in self.includes: args.append( '-I%s' %path )
		for macro in MACRO_DEFS: args.append( '-D%s' %macro )
		for macro in MACRO_UNDEFS: args.append( '-U%s' %macro )
		
		args.append( '-' )
		print( '_'*80 )
		print( ' '.join( args ) )
		print( '_'*80 )
		pipe = subprocess.Popen( 
			args, 
			stdin=subprocess.PIPE, 
			stdout=subprocess.PIPE, 
			stderr=subprocess.PIPE, 
			universal_newlines=True)
		#print source
		data, err = pipe.communicate( input=source )		# input=None
		if not data.strip():
			print( err )
			raise SyntaxError

		unused_macros = []
		if err.strip():
			srclines = source.splitlines()
			err = err.strip()
			for line in err.splitlines():
				_line = line.split()
				if 'warning:' in _line:
					#print( line )
					if 'warning: macro' in line:
						u = line.split('"')[1]
						if u in '({' or u in self.macro_globals: continue	# fixed march22, 2011
						if u not in unused_macros:
							unused_macros.append( u )
							linenum = _line[0].split(':')[1]	# hopefully this won't change with other versions of cpp
							linenum = int( linenum )-1
							self.parse_macro( u, linenum, srclines )

				elif 'error:' in line.lower().split():
					print( '-'*80 ); print(err); print( '-'*80 )
					print( line )
					print( 'C pre-processor error! giving up.')
					raise SyntaxError

		# remove bad stuff pycparser can not handle #
		if self.__class__ is CPlusPlus: d = data
		else: d = make_pycparser_compatible( data )
		f = open('/tmp/_debug_%s' %self.source_file,'wb')
		f.write(d); f.close()
		return d


## data = output of C pre processor ##
def make_pycparser_compatible( data ):
	## deprecated ##
	d = ''
	TYPEDEF_HACKS = [ 
		('char *', '__builtin_va_list'),
		('unsigned char', '_Bool'),	# pypy generated, check for _GNUC_ and uses _Bool
	]
	if '--no-gnu' in sys.argv:
		TYPEDEF_HACKS.append(('long long int', 'int64_t'))
	for type, name in TYPEDEF_HACKS: d += 'typedef %s %s;\n' %(type,name)
	################ above is deprecated

	skip = False
	for num, line in enumerate(data.splitlines()):
		if skip:
			if line.strip().endswith(';'): line = ';'; skip = False
			else: continue

		if line in ('char *__const__ * _PySequence_BytesToCharpArray(PyObject* self);', 'void _Py_FreeCharPArray(char *__const__ array[]);'):
			line = ''	# strange cases in python3.2/abstract.h

		if '__builtin_offsetof' in line.split() or '(__builtin_offsetof' in line.split():
			if 'pypy' in line: line = ';'	# pypy generated C
			else: line = line.replace('__builtin_offsetof', 'offsetof')

		if line.strip().startswith('__attribute__((format(printf,') and line.strip().endswith(')));'):
			line = ';'

		if '__attribute__((packed))' in line.split(): line = line.replace( '__attribute__((packed))', '' )

		if '__attribute__((malloc))' in line.split(): line = line.replace( '__attribute__((malloc))', '' )

		if '__attribute__((deprecated))' in line.split():	# alut.h
			line = line.replace( '__attribute__((deprecated))', '' )

		#if line.strip().endswith('__attribute__((__malloc__)) __attribute__((__alloc_size__(1)));'):	#glib/gslice.h:28
		#	line = line.replace( '__attribute__((__malloc__)) __attribute__((__alloc_size__(1)));', ';' )
		if '__attribute__((__malloc__))' in line.split() and line.strip().endswith(';'):
			line = line.split('__attribute__((__malloc__))')[0] + ';'

		if line.strip().endswith('__attribute__((warn_unused_result));'):
			line = line.replace('__attribute__((warn_unused_result));', ';' )
		if '__attribute__((warn_unused_result))' in line.split():
			_line = line.split('__attribute__((warn_unused_result))')[0]
			if line.strip().endswith(';'): _line += ';'
			line = _line

		if '((__malloc__));' in line.split(): line = line.replace('((__malloc__));', ';')	# stdio.h:225
		if '((__malloc__))' in line.split(): line = line.replace('((__malloc__))', '')

		if '__attribute__((visibility("default")))' in line.split():
			line = line.replace('__attribute__((visibility("default")))', '')

		if '__attribute__((__deprecated__))' in line.split():
			line = line.replace( '__attribute__((__deprecated__))', '' )	# ode/mass.h:69

		if '__extension__' in line.split(): line = line.replace('__extension__','')
		if '__attribute__' in line.split(): line = line.replace('__attribute__', '')
		if '__THROW' in line.split(): line = line.replace('__THROW', '')

		if '__inline__' in line.split(): line = line.replace( '__inline__', '' )
		if '__inline' in line.split(): line = line.replace('__inline', '' )	# odemath.h:316

		if '((__nothrow__))' in line.split(): line = line.replace('((__nothrow__))', '')	# inttypes.h
		if '((__nothrow__));' in line.split(): line = line.replace('((__nothrow__));', ';')

		if '((__const__))' in line.split(): line = line.replace('((__const__))', '')
		if '((__const__));' in line.split(): line = line.replace('((__const__));', ';')
		if '*__const' in line.split(): line = line.replace('*__const', '__const')	#unistd.h:541 sys_errlist.h
		if line.strip() == '((__const));': line = ';'	# /usr/include/ctype.h
		if '__const__' in line.split(): line = line.replace('__const__', 'const' )
		if '__const' in line.split(): line = line.replace('__const', 'const' )
		if '(__const' in line.split(): line = line.replace('(__const', '(const' )

		if '(__const__ ' in line: line = line.replace('(__const__', '(const' )
		if ',__const__' in line: line = line.replace( ',__const__', ',const' )

		if '***__restrict' in line.split(): line = line.replace('***__restrict', '***')	# dirent.h
		if '**__restrict' in line.split(): line = line.replace('**__restrict', '**')
		if '*__restrict' in line.split(): line = line.replace('*__restrict', '*' )
		if '__restrict' in line.split(): line = line.replace('__restrict', '' )

		if line.strip().startswith('((__format__ ('):		# stdio.h:385
			_s = line.strip()
			if _s.endswith( '))) ;' ) or _s.endswith(')));'): line = ';'

		if line.startswith('extern') and '((visibility("default")))' in line.split():		# SDL_cdrom.h
			line = line.replace( '((visibility("default")))', '' )

		# types.h #
		for ugly in ['((__mode__ (__QI__)));' , '((__mode__ (__HI__)));' , '((__mode__ (__SI__)));' , '((__mode__ (__DI__)));' , '((__mode__ (__word__)));']:
			if line.endswith( ugly ): line = line.replace(ugly, ';')

		if '__asm__' in line.split(): #and '__isoc99_' in line:
			if line.strip().endswith(';'): line = line.split('__asm__')[0] + ';'
			else: line = line.split('__asm__')[0]


		if '((__nonnull__' in line.split():		#unistd.h
			if line.strip().endswith(')));') or line.strip().endswith('))) ;') or line.strip().endswith('((__deprecated__)) ;'):
				line = line.split('((__nonnull__')[0] + ';'
			elif line.strip().endswith(';'):
				line = line.split('((__nonnull__')[0] + ';'	# this is always safe?

		if line.strip().endswith('((__noreturn__));'): line = line.replace('((__noreturn__));', ';')	#unistd.h:596 _exit
		if '((__pure__))' in line.split():		# string.h:45
			if line.strip().endswith(';'): line = line.split('((__pure__))')[0] + ';'
		if line.strip().endswith('__attribute__((__pure__));'):
			line = line.replace('__attribute__((__pure__));', ';')
		if line.strip().startswith('__attribute__((visibility("hidden")))'):	#glib-2.0/glib/gmessages.h:97
			line = line.replace('__attribute__((visibility("hidden")))', '')
		if line.strip().endswith('__attribute__;'):	# glib-2.0/glib/gmessages.h:113
			line = line.replace('__attribute__;', ';')
		if '__attribute__((__format_arg__' in line.split() and line.strip().endswith(';'):
			line = line.split('__attribute__((__format_arg__')[0] + ';'

		if line.strip().endswith('__attribute__((const));'): line = line.replace('__attribute__((const));', ';')	#glib-2.0/glib/gquark.h

		#if '__const struct' in line:	# time.h:187, this can go away, will pop __const in _fix_decl_name_type
		#	print('WARNING: %s' %line)
		#	line = line.replace( '__const struct', 'struct' )

		if line.strip().endswith( '((__transparent_union__));' ):	# stdlib.h:72
			line = line.replace( '((__transparent_union__));', ';' )

		if line.strip().endswith( '((__warn_unused_result__));' ):
			line = line.replace('((__warn_unused_result__));', ';' )	# stdlib.h:400

		if line.strip().endswith('__attribute__((__const__));'):	# glib-2.0/glib/gquark.h:39
			line = line.replace('__attribute__((__const__));', ';' )

		if '__attribute__((__format__' in line.split() and line.strip().endswith('));'):
			line = line.split('__attribute__((__format__')[0] + ';'

		if line.strip().endswith('__attribute__((__malloc__));'):
			line = line.replace( '__attribute__((__malloc__));', ';')

		if '((unused))' in line.split():	# glib-2.0/glib/gutils.h:300
			line = line.replace('((unused))', '')

		if '__attribute__((may_alias))' in line.split():	# glib-2.0/glib/gatomic.h:38
			line = line.replace('__attribute__((may_alias))', '')

		if line.strip().endswith('((__deprecated__));'):	#/usr/include/signal.h:196
			line = line.replace('((__deprecated__));', ';')

		if line.strip().endswith('__attribute__ ;'):		#/usr/include/bits/sigthread.h:33
			line = line.replace('__attribute__ ;', ';')

		if line.strip().endswith('__attribute__((__sentinel__));'):	#glib-2.0/gobject/gobject.h:414
			line = line.replace('__attribute__((__sentinel__));', ';')

		if line.strip().endswith('((__aligned__));'):
			line = line.replace('((__aligned__));', ';')

		if '((__regparm__' in line.split():	# pthread.h:665
			if line.strip().endswith(';'):
				line = line.split('((__regparm__')[0] + ';'
			elif line.strip().startswith('((__regparm__'): line = ''
		if line.strip() == '((__weak__))': line = ''

		if line.startswith('#pragma'): line = ''

		if line.startswith('extern int __sigsetjmp (struct __jmp_buf_tag') and line.endswith(';'):
			line = 'extern int __sigsetjmp ();'

		#if line == 'struct XnMutex;': line = 'typedef struct XnMutex;'
		if line == 'typedef XnMutex* XN_MUTEX_HANDLE;':	# strange that forcing these typedefs to int works
			line = 'typedef int XN_MUTEX_HANDLE;'
		if line == 'typedef XN_MUTEX_HANDLE XN_CRITICAL_SECTION_HANDLE;':
			line = 'typedef int XN_CRITICAL_SECTION_HANDLE;'

		if line.strip() == '((format (printf, 3, 4)));' or line.strip()=='((format (printf, 1, 2)));': line = ';'	# for blender.h

		if line.strip() == '((__pure__));': line = ';'	# /usr/include/wchar.h
		if line.strip().endswith('((__pure__));'): line = line.replace('((__pure__));', ';')

		## pypy hybrid gc creates this funny line in pypy_g_ll_arena_round_up_for_allocation
		#  l_v3659 = ((((l_arg0_6)>=(l_arg1_6)?(l_arg0_6):(l_arg1_6)) + (offsetof (struct rpy_memory_alignment_test2, s)-1)) & ~(offsetof (struct rpy_memory_alignment_test2, s)-1));
		if '& ~(offsetof (struct rpy_memory_alignment_test2' in line and line.strip().endswith(';'):
			line = ';'

		if line.strip().startswith('asm volatile') and line.strip().endswith(';'): line = ';'		# for boehm gc


		if line.strip().startswith('__asm__'):
			if line.strip().endswith(';'): line = ';'
			else: line = ''; skip = True

		if '__asm(' in line and line.strip().endswith(');'):	# darwin - stdio.h
			line = line.split('__asm(')[0] + ';'

		if '({ union { uint8_t b8[2]; uint16_t b16; } _tmp; uint16_t _tmp2 = (uint16_t)' in line: line = ';'	#libusb-1.0/libusb.h:886

		## android include/machine/_types.h		include/asm/types.h
		#if line.strip() == 'typedef __int8_t __int_least8_t;': line = 'typedef signed char __int_least8_t;'
		#if line.strip() == 'typedef __int8_t int8_t;' : line = 'typedef signed char int8_t;'
		if '__signed__' in line.split(): line = line.replace( '__signed__', 'signed' )
		if '__signed' in line.split(): line = line.replace( '__signed', 'signed' )

		if '__OSX_AVAILABLE_STARTING(' in line and line.endswith(';'):
			line = line.split( '__OSX_AVAILABLE_STARTING(' )[0] + ';'
		if line.strip() in ['__asm("_" "pselect" )', '__asm("_" "select" )']:		# darwin - select.h
			line = ''
		if '__OSX_AVAILABLE_BUT_DEPRECATED(' in line:
			if line.strip().endswith(';'):
				line = line.split('__OSX_AVAILABLE_BUT_DEPRECATED(')[0] + ';'
			else:
				line = line.split('__OSX_AVAILABLE_BUT_DEPRECATED(')[0]
				skip = True

		if line.strip().startswith('((format (printf,') and line.strip().endswith(')))'):
			line = ''

		#######################
		d += line + '\n'
	return d

TRANS_HEADER = '''

def printf( arg ): print( arg )

'''



class Emscripten(object):
	'''
	The old PyPy javascript backend would not likely produce better results than Emscripten+Closure,
	because PyPy's flowgraph is already low level, and the old js backend was not optimized for strict-javascript.
	The other advantage of Emscripten is translation of C libraries used via RFFI becomes possible.

	INSTALLING:
		sudo apt-get install llvm-gcc-4.2

	'''

	_config_ubuntu_mavrick = '''
TEMP_DIR='/dev/shm'
LLVM_ROOT=os.path.expanduser('/usr/bin')
LLVM_GCC=os.path.expanduser('/usr/bin/llvm-g++-4.2')
COMPILER_OPTS = ['-m32']
path = os.path.split(os.path.abspath(__file__))[0]
rel = os.path.join( path, '../../../bin/linux32/d8' )
V8_ENGINE = [  os.path.abspath(rel)  ]
COMPILER_ENGINE=V8_ENGINE
JS_ENGINE=V8_ENGINE
TIMEOUT = None
CLOSURE_COMPILER = None
SPIDERMONKEY_ENGINE = []
'''

	@classmethod
	def _ensure_setup(self):
		cfg = os.path.expanduser('~/.emscripten')
		if not os.path.isfile(cfg):
			f = open( cfg, 'wb' ); f.write( self._config_ubuntu_mavrick )
			f.close()


	@classmethod
	def compile( self, paths=[], source=None, includes=[], defs=[], links=[], cplusplus=False, optimize=2, pthread=True, glibc=True, gc=None ):
		self._ensure_setup()
		emmaken = os.path.join( RPYTHONIC_DIR, 'emscripten/tools/emmaken.py' )

		assert paths or source
		if not paths:
			if cplusplus: paths = ['/tmp/_compile_.cpp']
			else: paths = ['/tmp/_compile_.c']
			f = open(paths[0],'wb')
			f.write( source ); f.close()

		a = ''
		for x in includes: a += '-I%s ' %x
		b = ''
		for x in defs: b += '-D%s ' %x

		asmobjects = []
		for path in paths:
			# -c (do not run linker)
			n = os.path.splitext(os.path.split(path)[-1])[0]
			asmob = '/tmp/%s.o' %n
			asmobjects.append( asmob )
			cmd = '%s -c %s ' %(emmaken, path)
			if optimize: cmd += ' -O%s ' %optimize
			if pthread: cmd += ' -pthread '
			cmd += '-o %s %s %s' %(asmob,a,b)
			print( cmd )
			os.system( cmd )


		cmd = '%s ' %emmaken
		if pthread: cmd += ' -pthread '
		if glibc: cmd += ' -lrt '
		if gc=='boehm': cmd += ' -lgc '

		for lib in links:
			cmd += ' -l%s ' %lib		# name without path or 'lib' prefix or '.so' extension

		cmd += '-o /tmp/_emmaken_temp '
		for asmob in asmobjects: cmd += ' %s ' %asmob
		print( cmd )
		os.system( cmd )

		cmd = 'llvm-dis -show-annotations /tmp/_emmaken_temp'
		print( cmd )
		os.system( cmd )

		remdead = os.path.join( RPYTHONIC_DIR, 'emscripten/tools/dead_function_eliminator.py' )
		cmd = 'python %s /tmp/_emmaken_temp.ll /tmp/_optimized_.ll' %remdead
		print( cmd )
		os.system( cmd )

		#data = open( '/tmp/_emmaken_temp.ll', 'rb' ).read()
		#return data
		emscripten = os.path.join( RPYTHONIC_DIR, 'emscripten/emscripten.py' )
		d8 = os.path.join( RPYTHONIC_DIR, 'bin/linux32/d8' )
		cmd = '%s /tmp/_optimized_.ll %s > /tmp/_javascript_pass1' %(emscripten, d8)
		print( cmd )
		os.system( cmd )

		closure = os.path.join( RPYTHONIC_DIR, 'bin/Closure/compiler.jar' )
		# ADVANCED_OPTIMIZATIONS runs out of RAM on a 2GB machine!!!!
		cmd = 'java -jar %s --compilation_level SIMPLE_OPTIMIZATIONS --formatting PRETTY_PRINT --js=/tmp/_javascript_pass1 --js_output_file=/tmp/_javascript_pass2' %closure
		print( cmd )
		os.system( cmd )

		data = open( '/tmp/_javascript_pass2', 'rb' ).read()
		return data


class GCC(object):
	'''
       -ffast-math
           Sets -fno-math-errno, -funsafe-math-optimizations,
           -ffinite-math-only, -fno-rounding-math, -fno-signaling-nans and
           -fcx-limited-range.

           This option causes the preprocessor macro "__FAST_MATH__" to be
           defined.

           This option is not turned on by any -O option since it can result
           in incorrect output for programs which depend on an exact
           implementation of IEEE or ISO rules/specifications for math
           functions. It may, however, yield faster code for programs that do
           not require the guarantees of these specifications.

       -Os Optimize for size.  -Os enables all -O2 optimizations that do not
           typically increase code size.  It also performs further
           optimizations designed to reduce code size.

       -O3 Optimize yet more.  -O3 turns on all optimizations specified by -O2
           and also turns on the -finline-functions, -funswitch-loops,
           -fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize
           options.


       -freciprocal-math
           Allow the reciprocal of a value to be used instead of dividing by
           the value if this enables optimizations.  For example "x / y" can
           be replaced with "x * (1/y)" which is useful if "(1/y)" is subject
           to common subexpression elimination.  Note that this loses
           precision and increases the number of flops operating on the value.

           The default is -fno-reciprocal-math.


      -pthreads
           Add support for multithreading using the POSIX threads library.
           This option sets flags for both the preprocessor and linker.  This
           option does not affect the thread safety of object code produced
           by the compiler or that of libraries supplied with it.

       -pthread
           This is a synonym for -pthreads.

       -msmall-mem
       -mlarge-mem
           By default, GCC generates code assuming that addresses are never
           larger than 18 bits.  With -mlarge-mem code is generated that
           assumes a full 32 bit address.


	-freg-struct-return
		       Return "struct" and "union" values in registers when possible.
		       This is more efficient for small structures than
		       -fpcc-struct-return.

	'''
	@staticmethod
	def compile( name, paths=[], source=None, includes=[], defs=[], links=[], cplusplus=False, optimize=2, pthread=True, glibc=True, gc=None ):
		assert paths or source
		if not paths:
			if cplusplus: paths = ['/tmp/_compile_.cpp']
			else: paths = ['/tmp/_compile_.c']
			f = open(paths[0],'wb')
			f.write( source ); f.close()

		a = ''
		for x in includes: a += '-I%s ' %x
		b = ''
		for x in defs: b += '-D%s ' %x

		asmobjects = []
		for path in paths:
			# -c (do not run linker)
			n = os.path.splitext(os.path.split(path)[-1])[0]
			asmob = '/tmp/%s.o' %n
			asmobjects.append( asmob )
			cmd = 'gcc -c -fPIC %s ' %path
			if optimize: cmd += ' -O%s ' %optimize
			if pthread: cmd += ' -pthread '
			cmd += '-o %s %s %s' %(asmob,a,b)
			print( cmd )
			os.system( cmd )


		cmd = 'gcc -shared -Wl,-soname,lib%s.so ' %name
		if pthread: cmd += ' -pthread '
		if glibc: cmd += ' -lrt '
		if gc=='boehm': cmd += ' -lgc '

		for lib in links:
			cmd += ' -l%s ' %lib		# name without path or 'lib' prefix or '.so' extension, ie: 'OgreMain' not libOgreMain.so
		if IS32BIT: cachepath = os.path.join(CACHEDIR,'clibs/linux32')
		else: cachepath = os.path.join(CACHEDIR,'clibs/linux64')
		if not os.path.isdir(cachepath): os.makedirs( cachepath )
		libpath = os.path.join( cachepath, 'lib%s.so'%name )
		cmd += '-o %s ' %libpath
		for asmob in asmobjects: cmd += ' %s ' %asmob
		print( cmd )
		os.system( cmd )

		#try:
		lib=ctypes.CDLL(libpath)
		print( lib )
		#except:
		#	print( 'ERROR: generated lib is failed to load.' )
		#	assert 0
		return lib

############### new c++ ############### 
def has_valid_name( name, allow_namespace=False ):
	test = '()[]{}<>^|=~!*+-'
	if not allow_namespace: test += ':'
	for x in test:
		if x in name: return False
	else: return True


class CPP_variable( object ):
	def __init__(self,var=None, name=None, type=None, parent=None):
		self.parent = parent
		if var:
			for n in var.keys(): setattr( self, n, var[n] )	# assumes no dots or dashes in key names
		else:
			self.name = name
			self.type = type
		self.name = self.name.strip()
		#self.valid = has_valid_name( self.name, allow_namespace=True )
		self.valid = True

	def old(self):
		self.fundamental = True
		self.pointer = False
		self.reference = False
		self.constant = False
		self.static = False
		if '*' in self.type: self.pointer = True; self.type = self.type.replace('*','')
		if '&' in self.type: self.reference = True; self.type = self.type.replace('&','')
		if 'const' in self.type.split(): self.constant = True; self.type = self.type.replace('const', '')
		if 'static' in self.type.split(): self.static = True; self.type = self.type.replace('static', '')
		self.type = self.type.strip()

		self.classname = self.classtype = None
		self.ctype = self.cpptype = None
		self.typedef = None
		for a in self.type.split():
			if a not in 'struct union unsigned signed bool char short int float double long void': self.fundamental = False; self.identity = a.strip()
		if not self.fundamental:
			#print( 'non-fundamental: %s' %self.type )
			if self.identity in CPP_class.Classes:
				self.classtype = CPP_class.Classes[ self.identity ]
				#print( 'found class', self.classtype )
			elif self.identity in CPlusPlus.typedefs:
				#a = CPlusPlus.typedefs[ self.identity ]
				#while a in CPlusPlus.typedefs: a = CPlusPlus.typedefs[ a ]
				a = CPlusPlus.concrete_typedef( a )
				if '::' in a:
					self.classtype = 'typedef-class'
					self.cpptype = a
					self.ctype = 'void *'
					print( 'typppppppp', a )
				else: self.typedef = a; self.fundamental = True

			elif parent and parent.namespace:
				a = parent.namespace + '::' + self.identity
				if a not in CPlusPlus.typedefs: self.valid = False
				else:
					concrete = CPlusPlus.concrete_typedef( a )
					#while a in CPlusPlus.typedefs: a = CPlusPlus.typedefs[ a ]
					if '::' not in concrete: a = concrete
					if '::' in a:
						self.classtype = 'typedef-class'
						self.cpptype = a
						self.ctype = 'void *'
					else:
						self.typedef = a; 
						self.fundamental = True

			else:
				print( 'unresolved type:', self.type )
				self.valid = False

		if not self.ctype and not self.cpptype:
			if self.classtype:
				self.ctype = 'void*'
				self.cpptype = self.classtype.classpath
			else:
				if self.typedef: self.ctype = self.cpptype = self.typedef
				else: self.ctype = self.cpptype = self.type

	def is_fundamental( self ): return self.fundamental


class CPP_method( object ):
	def __init__(self, meth, parent):
		self.name = meth['name']
		#self.returns = meth[ 'rtnType' ]
		for tag in 'defined pure_virtual operator constructor destructor extern template virtual static explicit inline friend returns returns_pointer returns_fundamental returns_class'.split():
			setattr(self, tag, meth[tag])
		self.debug = meth['debug']

		self.arguments = []
		self.parent = parent
		self.namespace = parent.namespace
		self.valid = True
		for arg in meth[ 'parameters' ]:
			if arg:
				self.arguments.append( CPP_variable(arg, parent=self) )
				self.valid = self.arguments[-1].valid
				if not self.valid: break
			else:
				self.valid = False
				print('warning - method had unparseable argument:', self.name)

		if self.valid: self.valid = has_valid_name( self.name )

class CPP_class( object ):
	Classes = {}
	def __init__(self, klass):
		self.name = self.classpath = klass['name']
		CPP_class.Classes[ self.name ] = self
		self.namespace = klass['namespace']
		#self.classpath = '::'.join( self.namespace+[self.name] )
		if self.namespace: self.classpath = self.namespace + '::' + self.name
		self.inherits = klass['inherits']
		self.abstract = klass['abstract']
		self.parent = klass['parent']

		self.methods = []		# only interested in public?
		self.constructors = []
		self.properties = []
		for m in klass['methods']['public']:
			meth = CPP_method( m, parent=self )
			if meth.valid:
				if meth.name == self.name: self.constructors.append( meth )
				else: self.methods.append( meth )
		for p in klass['properties']['public']:
			self.properties.append( CPP_variable(p) )
		

	NumFuncs = 0
	def gen_wrapper( self ):
		m = {'class': self.name, 'classpath':self.classpath}

		cpp = [ '/* class %s  <abstract: %s> */' %(self.name,self.abstract) ]

		c = {'structs':[], 'declares':[], 'funcs':[]}
		py = {
			'struct': 'class _ctypes_%(class)s(ctypes.Structure): pass' %m, 
			'class' : 'class %(class)s(object):\n' %m,
			'body' : [],
			'methods' : [ 'def __init__(self): self._wrapped = self._ctypes_struct_()' ],
		}
		py['body'].append( '_ctypes_struct_  =  _ctypes_%(class)s' %m )

		for func in self.constructors:
			if not func.arguments:
				self.__class__.NumFuncs += 1
				cpp.append( 'void * new_object_%s() { return (void *)(new %s()); } ' %(self.__class__.NumFuncs, self.classpath) )

				self.__class__.NumFuncs += 1
				cpp.append( 'void delete_object_%s( void * obj ) { delete (%s *)(obj); } ' %(self.__class__.NumFuncs, self.classpath) )
				break


		for func in self.methods:
			if not func.valid: cpp.append( '/* %s.%s <invalid> */' %(self.classpath, func.name) ); continue
			elif func.virtual: cpp.append( '/* %s.%s <virtual> */' %(self.classpath, func.name) ); continue
			elif func.explicit: cpp.append( '/* %s.%s <explicit> */' %(self.classpath, func.name) ); continue
			elif func.static: cpp.append( '/* %s.%s <static> */' %(self.classpath, func.name) ); continue
			elif func.operator: cpp.append( '/* %s.%s <TODO operators> */' %(self.classpath, func.name) ); continue


			self.__class__.NumFuncs += 1
			cpp.append( '/* %s.%s' %(self.classpath, func.name) )
			cpp.append( func.debug )
			cpp.append( '*/')
			m['func'] = func.name
			m['signature'] = self.__class__.NumFuncs
			m['returns'] = 'void'	#func.returns
			m['wfunc'] = 'call__%(class)s__%(func)s__%(signature)s' %m
			m['args'] = ''
			m['wargs'] = ''
			m['typed_wargs'] = ''
			m['types'] = ''

			cargs		= ['void* object']
			cppargs		= [ ]

			for idx,arg in enumerate(func.arguments):
				m['args'] += ' %s,' %arg.name
				m['wargs'] += ' arg__%s,' %arg.name
				m['typed_wargs'] += ' %(type)s arg__%(name)s,' %{'type':arg.ctype, 'name':arg.name}
				m['types'] += '%s,' %arg.type

				if arg.ctype != arg.cpptype:
					cargs.append( 'void * arg%s' %idx )
					if arg.reference: cppargs.append( '(%s&)arg%s' %(arg.cpptype,idx) )
					elif arg.pointer: cppargs.append( '(%s*)arg%s' %(arg.cpptype,idx) )
					else: cppargs.append( '(%s&)arg%s' %(arg.cpptype,idx) )	# TODO, is this correct? how to cast from voidp to value?

				else:
					ptrs = '*' * arg.pointer
					if arg.constant and arg.reference: cargs.append( 'const %s & arg%s' %(arg.ctype,idx) )
					elif arg.constant:  cargs.append( 'const %s %s arg%s' %(arg.ctype,ptrs,idx) )
					elif arg.reference:  cargs.append( '%s & arg%s' %(arg.ctype,idx) )
					else: cargs.append( '%s %s arg%s' %(arg.ctype,ptrs,idx) )

					cppargs.append( 'arg%s' %idx )


			_methdef = '%(returns)s  extern_%(signature)s' %m
			_methdef += '( %s )  {' %(', '.join(cargs))
			cpp.append(  _methdef )
			_methbody = '	(( %(classpath)s *)object)->%(func)s' %m
			_methbody += '( %s );' %(',\n\t\t'.join(cppargs))
			cpp.append( _methbody )

			#if func.arguments:
			#	for u in 'args typed_wargs wargs types'.split(): m[u] = m[u][:-1]	# strip comma
			#	cpp.append( '%(returns)s  methodwrapper_%(signature)s( %(class)sOBJECT* w, %(typed_wargs)s )  {' %m )
			#	cpp.append( '	(( %(classpath)s *)w)->%(func)s( %(wargs)s );' %m )
			#else:
			#	cpp.append( '%(returns)s  methodwrapper_%(signature)s( %(class)sOBJECT* w ) {' %m )
			#	#cpp.append( '	return (void*)(( Ogre::%(class)s *)w)->%(func)s();' %m )
			#	cpp.append( '	(( %(classpath)s *)w)->%(func)s();' %m )
			cpp.append( '}' )

			## C wrapper - required? - or can the c++ lib with c linkage be called directly from ctypes?
			c['structs'].append( 'struct %(class)s;' %m )
			dec = '%(returns)s  %(wfunc)s ( struct %(class)s*, %(types)s );' %m
			c['declares'].append( dec )
			cwrap = '%(returns)s  C_%(wfunc)s ( struct %(class)s* w, %(typed_wargs)s ) { return %(wfunc)s( w, %(wargs)s ); }' %m
			c['funcs'].append( cwrap )

			## ctypes function
			f = '_cfunc_%(func)s  = _c_external_function(	"%(wfunc)s", ['		%m
			for arg in func.arguments:
				if arg.is_fundamental():
					f += '\n\t\t( "%s",\t\t%s, 1 ), ' %( arg.name, arg.type )
				else:
					f += '\n\t\t( "%s",\t\t_ctypes_%s, 1 ), ' %( arg.name, arg.type )
			f += '], %s  )' %func.returns
			py['body'].append( f )

			## python class wrapper methods
			py['methods'].append( 'def %(func)s(self, %(args)s):' %m )	# define method
			# any object pointers in args should point to ._wrapped
			mbody = '\tself._cfunc_%(func)s(self._wrapped, ' %m
			for arg in func.arguments:
				if arg.is_fundamental():
					mbody += '%s._wrapped, ' %arg.name
				else:
					mbody += '%s,' %arg.name
			mbody += ' ) '
			py['methods'].append(  mbody )		# call ctypes function

		for a in py['body'] + py['methods']:
			py['class'] += '\t%s\n' %a

		return '\n'.join(cpp), c, py

DD = None
class CPlusPlus( SourceCode ):
	typedefs = {}


	def parse( self, string, debug=False ):
		if '--no-preprocessor' in sys.argv: H = CppHeaderParser.CppHeader( self.source_url )
		else: H = CppHeaderParser.CppHeader( string, argType='string' )
		CPlusPlus.typedefs = H.typedefs
		self.classes = []
		for k in H.classes.values(): self.classes.append( CPP_class(k) )

		cppfile = '/tmp/%s_wrapper.cpp' %self.source_file
		cfile = 		'_cwrap_(%s).c' %self.source_file
		genpyheader = ''
		genpy = ''

		genc_structs = ''
		genc_declares = ''
		genc_funcs = ''

		gencpp = []
		gencpp.append( '/* generated by: RPythonic %s */' %VERSION )
		if self.source_file.endswith('.h') or self.source_file.endswith('.hpp'):
			gencpp.append( '#include "%s" ' %self.source_file )

		# typedef a struct for each object type, holds a single field 'object' #
		#for c in self.classes: gencpp.append( 'typedef struct {%s object; } %sOBJECT;' %(c.name,c.name) )
		#for c in self.classes: gencpp.append( 'typedef struct %sOBJECT;' %c.name )


		gencpp.append( 'extern "C" {' )
		for c in self.classes[:64]:
			if c.classpath.startswith('std::') or c.classpath.startswith('__cxxabiv1::'):
				gencpp.append( '/* SKIPPING: %s */' %c.classpath )
				continue
			if c.abstract:
				gencpp.append( '/* SKIPPING ABSTRACT CLASS: %s */' %c.classpath )
				continue
			if c.parent:
				gencpp.append( '/* SKIPPING NESTED CLASS: %s */' %c.classpath )
				continue


			cpp, c, py = c.gen_wrapper()
			gencpp.append( cpp )

			for s in c['structs']: genc_structs += s + '\n'
			for s in c['declares']: genc_declares += s + '\n'
			for s in c['funcs']: genc_funcs += s + '\n'
			genpyheader += py['struct'] + '\n'
			genpy += py['class'] + '\n'

		gencpp.append( '} /* end extern "C" */' )


		gencpp = '\n'.join( gencpp )
		self._gen_ctypes = genpyheader + genpy
		open( cppfile, 'wb' ).write( gencpp )
		#open( cfile, 'wb'		).write( '%s\n%s\n%s' %(genc_structs, genc_declares, genc_funcs) )
		GCC.compile( source=gencpp, includes=self.includes, defines=MACRO_DEFS, cplusplus=True )
		#for key in self.typedefs:
		#	print( key, self.typedefs[key] )
		#	#if 'StringBase' in key:
		#	#	print key, self.typedefs[key]
		assert 0


	def gen_rpython(self):	return self.gen_python()
	def gen_python(self): return '<todo>'
	def gen_rffi(self): return '<todo>'
	def gen_ctypes(self): return self._gen_ctypes


if RFFI_OUTPUT:
	PATH2PYPY = os.path.relpath( PATH2PYPY, os.path.split(RFFI_OUTPUT)[0] )
PYPY_HEADER = '''
## generated by RPythonic %s
## http://code.google.com/p/rpythonic/

import sys
if "%s" not in sys.path: sys.path.append( "%s" )
from pypy.rpython.lltypesystem import lltype, rffi
from pypy.rpython.tool import rffi_platform as platform
from pypy.translator.tool.cbuild import ExternalCompilationInfo
from pypy.rpython.annlowlevel import llhelper		# for rpy callbacks from C

def _def_cstruct( struct, *fields ):		# from lltype Struct __init__ (line 186)
	flds = {}; names = []; struct._arrayfld = None
	for name, typ in fields:
		name = 'c_'+name
		names.append(name)
		if name in flds: raise TypeError("repeated field name")
		flds[name] = typ
	if fields:
		for name, typ in fields[:-1]: typ._inline_is_varsize(False)
		name, typ = fields[-1]
		if typ._inline_is_varsize(True): struct._arrayfld = name
	struct._flds = lltype.frozendict(flds)
	struct._names = tuple(names)


''' %(VERSION, PATH2PYPY, PATH2PYPY)



test = None
class C( SourceCode ):		# using pycparser

	def parse(self, string, debug=0 ):	# called by init
		self.CTYPES_HEADER =  CTYPES_HEADER + '\n' + '''
_clib_name_ = '%s'
print('loading lib', _clib_name_)
print( os.path.abspath( os.path.curdir ) )
_ctypes_lib_ = _load_ctypes_lib( _clib_name_ )
assert _ctypes_lib_
print( _ctypes_lib_._name )
''' %self.shared_library_name

		self.set_rffi_header( string )

		#CParser = pycparser.c_parser.CParser( lex_optimize=False, yacc_debug=True, yacc_optimize=False )
		parser = CParser( lex_optimize=False, yacc_debug=True, yacc_optimize=False )
		if '--debug' in sys.argv:
			ast = parser.parse( string, debuglevel=2 )
		else:
			ast = parser.parse( string, debuglevel=debug )
		self.ast = ast
		self.python = self.output = []
		self.structs = []
		self.unions = []
		self.funcs = []
		self.funcdefs = []
		self.typedefs = []
		self.somethings = []
		self.indent = 0
		self.objects = []
		self.walk( ast )
		self.cyclics = Union.mark_cyclic()

	RFFI_HEADER = ''
	def set_rffi_header( self, data ):
		_config = CONFIG.copy()
		_config['includes'] = []
		if self.source_url.endswith('.h'): _config['includes'].append( self.source_url )

		if self.platform == 'android':		# for android we ignore pypy build system #
			eci = '_ECI_ = ExternalCompilationInfo()\n'
		else:						# use pypy build system to generate standalone executables #
			eci = '_ECI_ = ExternalCompilationInfo( includes = %(includes)s, include_dirs = %(include_dirs)s, link_files = %(link_libs)s )\n' %_config

		g = '''
try: platform.verify_eci(_ECI_)
except:
	print( 'can not verfiy ECI - this is ok if the target is Android' )
def _c_external_function(name, args=[], result=lltype.Void):	
	if len(args)==1 and args[0]==lltype.Void: args = []	# if function takes void then args=[], not args=[lltype.Void]
	func = rffi.llexternal(name, args, result, compilation_info=_ECI_)
	gen = False
	for arg in args:
		if arg is rffi.FLOAT: gen = True; break	# FLOAT (single) is the issue because 1.0 in python is a double
	if not gen: return func		# use directly
	else:	# generate wrapper
		r=rffi	# scope issue - pypy bug?
		head = ''; body = ''
		for i,arg in enumerate(args):
			head += 'a%s,' %i
			if arg is rffi.FLOAT: body += 'r.cast( r.FLOAT, a%s ),' %i
			else: body += 'a%s,' %i
		gen = 'lambda %s: func(%s)' %(head,body)
		print('wrapper func: %s: %s' %(name,gen))
		return eval( gen, locals() )\n'''

		C.RFFI_HEADER = PYPY_HEADER + eci + g

	def gen_rpython(self):	return self.gen_python()
	def gen_python(self):
		indent = []; s = ''
		for o in self.objects:
			for line in o.gen_python():
				s += ''.join( indent ) + line + '\n'
		return TRANS_HEADER + '\n' + s

	def generate_rffi_wrapper(self):
		a = '################ Globals ##############\n'
		for name in self.macro_globals:
			value = self.macro_globals_values[ name ]
			if type(value) is str: a += '%s = "%s"\n' %(name,value)
			else: a += '%s = %s\n' %(name,value)
		a += '################# ENUMS ################\n'
		a += '\n'.join( [o.gen_rffi() for o in SomeThing.get_enums()] ) + '\n'
		us = SomeThing.get_unions_and_structs()

		a += '################# Forwardref Structs ################\n'
		a += '\n'.join( [o.gen_rffi(declare=False, forward=True) for o in us] ) + '\n'
		a += '################# Declare Structs ################\n'
		a += '\n'.join( [o.gen_rffi(declare=True) for o in us] ) + '\n'
		a += '################# Define Structs ################\n'
		a += '\n'.join( [o.gen_rffi(declare=False) for o in us] ) + '\n'
		a += '################# Become Structs ################\n'
		a += '\n'.join( [o.gen_rffi(declare=False, become=True) for o in us] ) + '\n'
		a += '################# Functions ################\n'
		a += '\n'.join( [o.gen_rffi() for o in SomeThing.get_funcs()] )
		return self.RFFI_HEADER + a

	def generate_ctypes_wrapper(self):	
		a = '## macro globals ##\n'
		for name in self.macro_globals:
			value = self.macro_globals_values[ name ]
			if type(value) is str: a += '%s = "%s"\n' %(name,value)
			else: a += '%s = %s\n' %(name,value)

		a += '## enums ##\n'
		a += '\n'.join( [o.gen_ctypes() for o in SomeThing.get_enums()] ) + '\n'
		a += '## simple enums ##\n'
		a += 'RPYTHONIC_GLOBAL_ENUMS = { \n'
		for o in SomeThing.get_enums():
			if not o.is_named_enum():
				a += o.dict_format() + '\n'
		a += '\n}\n'

		## declare unions/structs first, so that they can self-reference
		u = SomeThing.get_unions_and_structs()
		a += '\n'.join( [o.gen_ctypes(declare=True) for o in u] ) + '\n'

		## func prototypes ##
		#for o in SomeThing.get_funcs(): a += '%s\n' %o.gen_ctypes(prototype=True)
		protos = []
		for o in u:
			for f in o.functions():
				#n = f.name()
				n = f.type()
				if n.startswith('function:'):
					n = n.split(':')[-1]
					if n not in protos: protos.append( n )
		## check for functions that take arguments pointing to another function(callback)
		for func in SomeThing.get_funcs():
			for arg in func.args:
				argtype = arg.type()
				if argtype.startswith('function:'):
					n = argtype.split(':')[-1]
					if n not in protos: protos.append( n )

		## no need for messy func prototypes - may18th ##
		#a += '## callback prototypes ##\n'
		#for n in protos:
		#	if n in SomeThing.Functions:
		#		func = SomeThing.Functions[ n ]
		#		a += '%s\n' %func.gen_ctypes(prototype=True)
		#	else: assert 0

		a += '## union and structures ##\n'
		## define unions/structs members (must be ordered), cyclic fields can still break ctypes - is that possible in C?
		u = SomeThing.get_unions_and_structs( sort=True )
		a += '\n'.join( [o.gen_ctypes(declare=False) for o in u] ) + '\n'

		a += '## wrapper functions ##\n'
		## write wrapper functions
		for o in SomeThing.get_funcs():
			if not o.name().startswith('__') and not o.static:
				a += '%s\n' %o.gen_ctypes()

		_tail = [
				'_rpythonic_convert_structs_to_objects()',
				CTYPES_FOOTER,	# this must come after structs are converted to smart-objects
				'_rpythonic_setup_return_wrappers()',
				'_rpythonic_make_nice_global_enums_()',
				'_rpythonic_clean_up_missing_functions_()',
				RAYMOND_HETTINGER,
				#'hettinger_transform()',	# can be slow for big ones like gtk
		]
		return self.CTYPES_HEADER + '\n' + a + '\n' + '\n'.join(_tail)



	def get_func_names( self ): return [ f.name for f in self.funcs ]
	def get_struct_names( self ): return [ s.name for s in self.structs ]


	def show( self ):
		for line in self.python: print( line )

	def walk( self, node ):
		#if isclass( node, 'Struct' ):
		#	self.structs.append( Struct(node) ); print 'this happens? struct without declare'; raise SyntaxError
		#elif isclass( node, 'Union' ):
		#	self.unions.append( Union(node) ); print 'this happens? union without declare'; raise SyntaxError
		if isclass( node, 'FuncDef', 'FuncDecl' ):
			o = Function(node)
			self.funcs.append( o )
			self.objects.append( o )
		elif isclass( node, 'Decl', 'TypeDecl', 'PtrDecl', 'Typedef' ):
			o = SomeThing(node)
			self.somethings.append( o )
			self.objects.append( o )
		else:
			print( 'skipping', node )
			children = node.children()
			if children:
				for child in children:
					self.walk( child )


if pycparser:
	class CParser( pycparser.c_parser.CParser ):
		#def p_pp_directive(self,p):
		#	""" pp_directive  : PPHASH 
		#	"""
		#	print( 'FIXME on new pycparser update' )	#example: #pragma pack (push, 1)

		def p_decl_body(self,p):
			""" decl_body : declaration_specifiers init_declarator_list_opt
			"""
			#pycparser.c_parser.CParser.p_decl_body(self,p)
			try: pycparser.c_parser.CParser.p_decl_body(self,p)
			except:
				spec = p[1]
				print('_'*80)
				print(spec)
				for t in spec['type']: print('decl body', t )
				raise SyntaxError

		def p_error(self, p):
			#print( dir(self.cparser))
			#print( 'state stack:')

			#print( self.cparser.symstack )
			#print( dir(self.clex) )
			#print( self.clex.tokens )
			if '--skip-parser-errors' in sys.argv:
				if p:
					pprint( 'pycparser error, before: %s' %p.value, 1 )
					pprint( p.lineno, 1 )
				else: pprint( 'error at end of file!' )
			else:
				#print( self.cparser.productions )
				#print( self.cparser.statestack )
				#for state in self.cparser.statestack: print( '\t%s' %self.cparser.productions[state] )
				print(p)
				if p: self._parse_error( 'before: %s' % p.value, self._coord(p.lineno))
				else: self._parse_error('At end of input', '')

		# Due to the order in which declarators are constructed,
		# they have to be fixed in order to look like a normal AST.
		# 
		# When a declaration arrives from syntax construction, it has
		# these problems:
		# * The innermost TypeDecl has no type (because the basic
		#   type is only known at the uppermost declaration level)
		# * The declaration has no variable name, since that is saved
		#   in the innermost TypeDecl
		# * The typename of the declaration is a list of type 
		#   specifiers, and not a node. Here, basic identifier types
		#   should be separated from more complex types like enums
		#   and structs.
		#
		# This method fixes these problem.
		#
		def _fix_decl_name_type(self, decl, typename):
			""" Fixes a declaration. Modifies decl.
			"""
			c_ast = pycparser.c_ast
			# Reach the underlying basic type
			#
			type = decl
			while not isinstance(type, c_ast.TypeDecl): type = type.type

			decl.name = type.declname
			type.quals = decl.quals

			# The typename is a list of types. If any type in this 
			# list isn't a simple string type, it must be the only
			# type in the list (it's illegal to declare "int enum .."
			# If all the types are basic, they're collected in the
			# IdentifierType holder.
			#
			if '__const' in typename: typename.remove('__const')	# this solves some rare cases
			for tn in typename:
				if not isinstance(tn, str):
					if len(typename) > 1:
						if '--skip-parser-errors' in sys.argv:
							pprint( 'WARNING: Invalid multiple types specified: %s' %tn.coord, 1 )
							return decl
						else:
							pprint( typename, 1 )
							self._parse_error("Invalid multiple types specified", tn.coord)
					else:
						type.type = tn
						return decl

			type.type = c_ast.IdentifierType(typename)
			return decl



class AndroidPackage( object ):
	'''
	Requires:
		1. ant	(ubuntu: "apt-get install ant")
		2. Android 2.3.3 (API level 10)
		3. hack pypy source code - see below

	Hack PyPy:
		pypy/translator/c/src/profiling.c
			line3: #if defined(__GNUC__) && defined(__linux__)
			change-to: #if defined(__GNUC__) && defined(__linux__) && !defined(ANDROID)
		pypy/translator/c/src/ll_strod.h
		replaces: lines 43 and 112:
		# ifdef ANDROID
		  decimal_point = ".";
		  decimal_point_len = 1;
		# else
		  locale_data = localeconv();
		  decimal_point = locale_data->decimal_point;
		  decimal_point_len = strlen(decimal_point);
		# endif

	'''

	DROID_SHARED_INCLUDE = '''
	#include <jni.h>
	#include <errno.h>
	#include <EGL/egl.h>
	#include <GLES/gl.h>
	#include <android/sensor.h>
	#include <android/log.h>
	#include <android_native_app_glue.h>

	'''

	DROID_NATIVE_WRAPPER = '''
	struct android_app* MyAndroidApp;	/* declare global */
	void* _get_android_app_state_() { return (void *)MyAndroidApp; }
	void android_main(struct android_app* state) {
		MyAndroidApp = state;		/* set android_app to global */
		app_dummy();				/* Make sure glue isn't stripped. */
		instrument_setup();			/* translator/c/src/instrument.h */
		RPython_StartupCode();		/* testing_1.c */
		pypy_g_entrypoint(NULL);	/* implement.c */
	}
	'''

	SDK_ROOT = NDK_ROOT = None
	@classmethod
	def set_sdk_root( self, path ):
		path = os.path.abspath( path )
		assert os.path.isdir( path )
		self.SDK_ROOT = path
	@classmethod
	def set_ndk_root( self, path ):
		path = os.path.abspath( path )
		assert os.path.isdir( path )
		self.NDK_ROOT = path

	def upload( self ):
		adb = os.path.join( self.sdk_platform_tools, 'adb' )
		cmd = '%s -e install -r %s' %(adb,self.apk)
		print( cmd )
		os.system( cmd )

	def __init__(self, headers, sources, name='myapp', ndk_version='android-9'):
		assert Android.SDK_ROOT
		assert Android.NDK_ROOT
		self.sdk_tools = os.path.join( Android.SDK_ROOT, 'tools' )
		assert os.path.isdir( self.sdk_tools )
		self.sdk_platform_tools = os.path.join( Android.SDK_ROOT, 'platform-tools' )
		assert os.path.isdir( self.sdk_platform_tools )


		self.ndk_version = ndk_version
		self.ndk_platform = os.path.join( 
			Android.NDK_ROOT, 
			'platforms/%s/arch-arm/' %self.ndk_version
		)
		assert os.path.isdir( self.ndk_platform )
		self.ndk_usr = os.path.join( self.ndk_platform, 'usr')
		self.ndk_include = os.path.join( self.ndk_usr, 'include' )
		self.ndk_lib = os.path.join( self.ndk_usr, 'lib' )
		assert os.path.isdir( self.ndk_usr )
		assert os.path.isdir( self.ndk_include )
		assert os.path.isdir( self.ndk_lib )

		self.pypy_include = os.path.join(PATH2PYPY,'pypy/translator/c/')
		assert os.path.isdir( self.pypy_include )

		from pypy.tool.udir import udir
		print('-'*80); print('#### CREATING NEW ANDROID PROJECT ####')
		## android NDK expects a 'jni' folder under project directory ##
		jnidir = udir.join('jni').ensure(dir=1)	# pypy udir automatically gives us a temp dir
		projectdir = os.path.split( jnidir.strpath )[0]
		self.new_project( projectdir, name=name )
		print( projectdir )
		print('-'*80)
		## make things simple, copy everything to jnidir ##
		for h in headers:
			h.copy( jnidir )
			#n = jnidir.join( h.basename )
			#n.write( ANDROID_HEADER_HACK + '\n' + h.read() )
		for f in sources:
			if f.basename.startswith('module'):
				data = f.read()
				data = data.replace( '\nextern int errno;\n', '\n\n' )	# ugly hack
				n = jnidir.join( f.basename )
				n.write( data )
			#elif f.basename.startswith('testing_'):	# target
			elif f.basename == 'implement.c':
				data = self.DROID_SHARED_INCLUDE + f.read() + self.DROID_NATIVE_WRAPPER
				n = jnidir.join( f.basename )
				n.write( data )
			else: f.copy( jnidir )


		mk = self.new_android_makefile(sources, path=jnidir)

		ndkbuild = os.path.join(self.NDK_ROOT,'ndk-build')
		assert os.path.isfile( ndkbuild )
		print('-'*80); print('#### %s ####'%ndkbuild); print('-'*80)
		os.system( 'cd %s; %s -B V=1' %(projectdir, ndkbuild))
		print('-'*80)

		os.system( 'cd %s; ant debug' %projectdir )

		print( projectdir )
		self.apk = os.path.join( projectdir, 'bin/%s-debug.apk'%name )
		assert os.path.isfile( self.apk )
		self.upload()

		tar = tarfile.open(name='/tmp/my_android_project.tar.gz', mode = 'w:gz')
		tar.add(projectdir)
		tar.close()




	def new_project( self, path, name='my_android_app', activity='rpython_activity', package='com.rpython.tests' ):
		cmd = '%s create project ' %os.path.join( self.sdk_tools, 'android' )
		cmd += ' --target "android-10" --name %s' %name
		cmd += ' --path %s' %path
		cmd += ' --activity %s' %activity
		cmd += ' --package %s' %package
		os.system(cmd)
		## override AndroidManifest so that android:hasCode="false" ##

	def new_android_makefile(self, cfiles, path=None, exe_name=None, shared=False):
		shared = []
		static = []
		for c in cfiles:
			#if c.basename.startswith('testing'): shared.append( c )
			if c.basename == 'implement.c': shared.append( c )
			else: static.append( c )

		appmk = path.join( 'Application.mk' )
		appmk.write( 'APP_ABI := armeabi armeabi-v7a\nAPP_PLATFORM := android-9\n' )

		mk = path.join( 'Android.mk' )
		g = 'LOCAL_PATH := $(call my-dir)\n'	# note no whitespace after $(call my-dir) ## make: *** No rule to make target

		staticnames = 'android_native_app_glue'
		for c in static:
			g += 'include $(CLEAR_VARS) \n'
			g += 'LOCAL_CFLAGS := -I%s\n' %self.pypy_include
			g += 'LOCAL_MODULE := %s \n' %c.purebasename
			g += 'LOCAL_SRC_FILES := %s \n' %c.basename
			g += 'include $(BUILD_STATIC_LIBRARY) \n'
			staticnames += ' '+c.purebasename

		for c in shared:
			g += 'include $(CLEAR_VARS) \n'
			g += 'LOCAL_CFLAGS := -I%s\n' %self.pypy_include
			g += 'LOCAL_MODULE := %s \n' %c.purebasename
			g += 'LOCAL_SRC_FILES := %s \n' %c.basename
			g += 'LOCAL_LDLIBS    := -llog -landroid -lEGL -lGLESv1_CM\n'
			g += 'LOCAL_STATIC_LIBRARIES := %s\n' %staticnames.strip()
			g += 'include $(BUILD_SHARED_LIBRARY) \n'
			g += '$(call import-module,android/native_app_glue)\n'

		mk.write( g )
		print('_'*80); print( g ); print('_'*80)
		return mk






class _rpy_func_wrapper(object):		# NOT RPYTHON
	def __init__(self,func):
		self.function = func		# this is replaced upon call to RPython.cache()
	def __call__( self, *args, **kw ):
		return self.function( *args, **kw )

class _rpy_func_bind(object):		# @sub-decorator
	# NOT RPYTHON, because of __call__
	# pypy reports error: File "../../pypy/pypy/annotation/bookkeeper.py", line 530, in getdesc pyobj,))
	#Exception: unexpected prebuilt constant: <rpythonic.rpythonic._rpy_func_bind object at 0xb766ab8c>
	def __init__(self,kw, stackless=False):
		self.argtypes = kw
		self.stackless = stackless

	def __call__(self,func):
		self.function = func
		self.name = func.func_name
		self.arguments = args = []

		spec = inspect.getargspec( func )
		if spec.args: nargs = len(spec.args)
		else: nargs = 0
		#if func.func_defaults and nargs != len(func.func_defaults): assert 0		# TODO
		#elif not func.func_defaults and spec.args:		# force defaults
		#	for arg in spec.args: args.append( self.argtypes[arg] )
		#	func.func_defaults = tuple( args )

		if spec.args:
			if self.argtypes:
				for arg in spec.args: args.append( self.argtypes[arg] )
			elif func.func_defaults:
				assert len(spec.args) == len(func.func_defaults)
				for i,arg in enumerate(spec.args): args.append( type(func.func_defaults[i]) )
			else:	# 'you must either provide keyword defaults or declare the types in the decorator'
				raise SyntaxError

		self.wrapper = _rpy_func_wrapper(func)
		return self.wrapper



class _rsingleton_(object):
	def __init__(self):
		self._locks_ = {}
	def _create_default_lock( self ): self._Lock_()

#class _RPY_(object): pass		# this works until you start dynamically adding things to _RPY_ from rpython-space
_RPY_ = _rsingleton_()		# just a container for the hacks below

def _rpy_object_getattr(self,name):
	#print 'get prop', name
	if hasattr( self._pointer.contents, 'mro_inst_'+name ):
		return getattr( self._pointer.contents, 'mro_inst_'+name )
	else:
		return getattr( self._pointer.contents, 's_inst_'+name )

def _rpy_threadsafe(func, lockname, *args ):	# RPYTHON
	if lockname in _RPY_._locks_:		# the lock is created Python-side, so it may or may not exist
		lock = _RPY_._locks_[ lockname ]
		lock.acquire()
		func(*args)
		lock.release()
	else:
		func(*args)

def _rpy_stackless_entrypoint( argc ):
	_RPY_._create_default_lock()
	_RPY_._stackless_()		# stackless entry point can take args anyways
	return 1


class _threadsafe(object):
	def __init__(self, name ):
		self.name = name		# semaphore name
	def __call__(self, func):
		setattr( _RPY_, '_threadsafe_%s' %func.func_name, func )
		e = 'lambda *args: _rpy_threadsafe(_RPY_._threadsafe_%s, "%s", *args)' %(func.func_name, self.name)
		g = eval( e )
		g.func_name = func.func_name
		return g

# the host may not allow this #
try:
	ctypes.CDLL('')
	ALLOWS_CTYPES_HOST_CDLL = True
except:
	ALLOWS_CTYPES_HOST_CDLL = False

if not ALLOWS_CTYPES_HOST_CDLL:
	class Lock(object): pass
else:
	class Lock(object):		# ctypes based thread lock with optional name
		lib = ctypes.CDLL('')
		_sem_open = lib.sem_open
		_sem_post = lib.sem_post
		_sem_wait = lib.sem_wait
		_sem_open.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_int, ctypes.c_uint]
		_sem_open.restype = ctypes.c_void_p
		_sem_post.argtypes = [ctypes.c_void_p]
		_sem_post.restype = ctypes.c_int
		_sem_wait.argtypes = [ctypes.c_void_p]
		_sem_wait.restype = ctypes.c_int

		def __init__(self, name=SEM_NAME, mode=600 ):
			self.name = name
			self.handle = self._sem_open( name, os.O_CREAT, mode, 1 )
			print( 'ctypes semaphore', self.handle )
		def acquire(self):
			a = self._sem_wait( self.handle )
			#print( 'acquire', a )
		def release(self):
			a = self._sem_post( self.handle )
			#print( 'release', a )

class AndroidEngine(object):	# RPYTHON
	def __init__(self, rpy):
		from pypy.rpython.lltypesystem import lltype, rffi
		self.rffi = rffi
		self.lltype = lltype
		self.rpy = rpy
		self.x = self.y = 0
		self.glue = rpy.rpyimport('android_native_app_glue')
		ptr = rffi.Ptr( self.glue.android_app )
		self.get_android_app_state = rffi.llexternal('_get_android_app_state_', [], ptr )
		self.EGL = rpy.rpyimport( 'EGL' )

		self.on_save_state = None
		self.on_terminate_window = None
		self.on_focus_gained = None
		self.on_focus_lost = None


	def setup(self):	# RPYTHON: user must call this before any other function
		self.app = self.get_android_app_state()
		self.app.onAppCmd( self.command_handler )	# takes *args
		self.app.onInputEvent( self.input_handler )

	def input_handler( self, app, event ):
		glue = self.glue
		t = glue.AInputEvent_getType(event)
		if t == glue.AINPUT_EVENT_TYPE_MOTION:
			self.x = glue.AMotionEvent_getX(event, 0)
			self.y = glue.AMotionEvent_getY(event, 0)
			return 1
		else: return 0


	def command_handler(self, app, cmd ):
		glue = self.glue
		if cmd == glue.APP_CMD_SAVE_STATE:
			if self.on_save_state: self.on_save_state( self )
		elif cmd == glue.APP_CMD_INIT_WINDOW:
			self.setup_display()
		elif cmd == glue.APP_CMD_TERM_WINDOW:
			if self.on_terminate_window: self.on_terminate_window( self )

		elif cmd == glue.APP_CMD_GAINED_FOCUS:
			if self.on_focus_gained: self.on_focus_gained( self )

		elif cmd == glue.APP_CMD_LOST_FOCUS:
			if self.on_focus_lost: self.on_focus_lost( self )



	def setup_display( self ):
		rffi = self.rffi
		e = self.EGL
		display = e.eglGetDisplay( e.EGL_DEFAULT_DISPLAY)
		self.display = display	# void-pointer
		e.eglInitialize(display, 0, 0)

		# Here specify the attributes of the desired configuration.
		# Below, we select an EGLConfig with at least 8 bits per color
		# component compatible with on-screen windows
		attribs = [
			e.EGL_SURFACE_TYPE,
			e.EGL_WINDOW_BIT,
			e.EGL_BLUE_SIZE, 8,
			e.EGL_GREEN_SIZE, 8,
			e.EGL_RED_SIZE, 8,
			e.EGL_NONE
		]
		config = self.lltype.voidp()

		# Here, the application chooses the configuration it desires. In this
		# sample, we have a very simplified selection process, where we pick
		# the first EGLConfig that matches our criteria.
		e.eglChooseConfig(display, attribs, config, 1, numConfigs)

		# EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is
		# guaranteed to be accepted by ANativeWindow_setBuffersGeometry().
		# As soon as we picked a EGLConfig, we can safely reconfigure the
		# ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID. 
		e.eglGetConfigAttrib(display, config, e.EGL_NATIVE_VISUAL_ID, format)

		e.ANativeWindow_setBuffersGeometry(self.app.window, 0, 0, format)

		surface = e.eglCreateWindowSurface(display, config, self.app.window, rffi.NULL)
		context = e.eglCreateContext(display, config, rffi.NULL, rffi.NULL)

		e.eglMakeCurrent(display, surface, surface, context)

		e.eglQuerySurface(display, surface, e.EGL_WIDTH, w)
		e.eglQuerySurface(display, surface, e.EGL_HEIGHT, h)

		self.display = display
		self.context = context
		self.surface = surface
		self.width = w
		self.height = h


class RPython(object):
	@staticmethod
	def acquire_lock(): _RPY_._locks_[ SEM_NAME ].acquire()
	@staticmethod
	def release_lock(): _RPY_._locks_[ SEM_NAME ].release()

	def rpyimport( self, mname):
		return _load( mname, platform=self.platform )

	def rcallback( self, signature_pointer, callback ):
		from pypy.rpython.annlowlevel import llhelper
		return llhelper(signature_pointer, callback)

	def __init__(self, platform='linux', threading=False, gc='ref'):
		self.platform = platform
		if platform in 'android ios'.split():
			from pypy.rpython.lltypesystem import lltype, rffi
			self.rffi = rffi
			self.lltype = lltype
			if platform == 'android':
				self.engine = AndroidEngine( self )



		self._stackless = False
		self._threading = threading
		self._gc = gc
		self.wrapped = []
		self.classes = []
		#if stackless:
		if 1: self._setup()
		#except:
		#	print( 'pypy not found, this is ok if your only loading from cache' )
		#	self.AbstractThunk = object
		if threading: self._setup_threading()


	_STANDALONE_ = None
	def standalone( self, func ):		# decorator
		#func.func_name = 'rpythonic_main'
		RPython._STANDALONE_ = func
		exec( 'def entrypoint( argv ): RPython._STANDALONE_(); return 1' )
		self._entrypoint_ = entrypoint
		return func

	def compile( self, inline=True, name='testing' ):
		mode = self.platform
		assert mode in 'linux javascript android'.split()
		if mode=='javascript':
			headers,sources = translate_rpython( self._entrypoint_, inline=False )
			_paths = [ c.strpath for c in sources ]
			_pypyinc = os.path.join(PATH2PYPY,'pypy/translator/c/')
			if _pypyinc not in INCLUDE_DIRS: INCLUDE_DIRS.append( _pypyinc )
			js = Emscripten.compile(  paths = _paths, includes = [ _pypyinc ] )
			return js

		if mode=='android':
			headers,sources = translate_rpython( self._entrypoint_, inline=inline )
			return AndroidPackage( headers, sources, name )

		else:
			exe = translate_rpython( self._entrypoint_, inline=inline, compile=True )
			print( exe.strpath )
			return exe

	#def threadsafe(self, semname=SEM_NAME):
	#	if not self._threading: self._setup_threading()
	#	self._threading = True
	#	w = _threadsafe( semname )
	#	return w

	def _setup_threading(self):
		from pypy.rpython.lltypesystem import rffi, lltype
		self._threading = True
		@self.object
		class RLock(object):
			# The oflag argument specifies flags that control the operation of the call. If O_CREAT is specified in oflag, 
			# then the semaphore is created if it does not already exist. The owner (user ID) of the semaphore is set to
			# the effective user ID of the calling process. The group ownership (group ID) is set to the effective group
			# ID of the calling process. If both O_CREAT and O_EXCL are specified in oflag, then an error is returned
			# if a semaphore with the given name already exists.'''
			def __init__(self, name=SEM_NAME):
				print( 'creating new named semaphore: %s' %name )
				if name not in _RPY_._locks_: _RPY_._locks_[ name ] = self
				self.name = name
				charp = rffi.str2charp(name)
				#self.handle = _RPY_._sem_open( name, os.O_CREAT | os.O_EXCL, 0600, 0 )
				#self.handle = _RPY_._sem_open( name, os.O_CREAT, 0644, 1 )	# allow creation and recreation
				self.handle = _RPY_._sem_open( 
					charp, 
					rffi.cast(rffi.INT,os.O_CREAT), 
					rffi.cast(rffi.INT,600), 
					rffi.cast(rffi.UINT,1) 
				)	# allow creation and recreation
				print( 'sem handle', self.handle )
				#if self.handle == -1:
				#	print( 'SEM OPEN FAILED!' )
				#try: _RPY_._sem_unlink(self.name)
				#except OSError: print( 'SEMAPHORE UNLINK FAILED: %s' %self.name )

				#The sem_unlink subroutine removes the semaphore named by the string name.
				#If the semaphore named by name is currently referenced by other processes, then sem_unlink has no effect on the state of the semaphore. If one or more processes have the semaphore open when sem_unlink is called, destruction of the semaphore is postponed until all references to the semaphore have been destroyed by calls to sem_close, _exit, or exec. Calls to sem_open to recreate or reconnect to the semaphore refer to a new semaphore after sem_unlink is called.
				#The sem_unlink subroutine does not block until all references have been destroyed, and it returns immediately.

			#def unlink(self): _RPY_._locks_.remove( self.name )
			def release( self ): return _RPY_._sem_post( self.handle )
			def acquire( self ):
				block = True
				# sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, 
				# then call returns an error (errno set to EAGAIN) instead of blocking.
				if block: return _RPY_._sem_wait( self.handle )
				else: return _RPY_._sem_trywait( self.handle )

		self.RLock = RLock
		_RPY_._RLock_ = RLock



	def _setup(self):
		import pypy.rlib.rcoroutine
		d = pypy.rlib.rcoroutine.make_coroutine_classes(object)
		RPython._stackless_syncstate = d['syncstate']
		RPython.Coroutine = d['Coroutine']
		RPython.AbstractThunk = d['AbstractThunk']
		import pypy.module._multiprocessing.interp_semaphore as mp
		#for n in '_sem_open _sem_unlink _sem_wait _sem_trywait _sem_post _select'.split():
		#	setattr( _RPY_, n, getattr(mp,n) )

		from pypy.translator.tool.cbuild import ExternalCompilationInfo
		from pypy.rpython.tool import rffi_platform as platform
		from pypy.rpython.lltypesystem import rffi, lltype
		eci = ExternalCompilationInfo(
			includes = ['sys/time.h',
			'limits.h',
			'semaphore.h'],
			libraries = ['rt'],
		)
		class CConfig:
			_compilation_info_ = eci
			TIMEVAL = platform.Struct('struct timeval', [('tv_sec', rffi.LONG), ('tv_usec', rffi.LONG)])
			TIMESPEC = platform.Struct('struct timespec', [('tv_sec', rffi.TIME_T), ('tv_nsec', rffi.LONG)])
			SEM_FAILED = platform.ConstantInteger('SEM_FAILED')
			SEM_VALUE_MAX = platform.ConstantInteger('SEM_VALUE_MAX')
			SEM_TIMED_WAIT = platform.Has('sem_timedwait')
		config = platform.configure(CConfig)
		TIMEVAL        = config['TIMEVAL']
		TIMESPEC       = config['TIMESPEC']
		TIMEVALP       = rffi.CArrayPtr(TIMEVAL)
		TIMESPECP      = rffi.CArrayPtr(TIMESPEC)
		SEM_T          = rffi.COpaquePtr('sem_t', compilation_info=eci)
		## even without a wrapper and holding the GIL, it is still not threadsafe
		def external(name, args, result):
			return rffi.llexternal(name, args, result, compilation_info=eci, threadsafe=True, _nowrapper=True)
		_RPY_._sem_open = external('sem_open', [rffi.CCHARP, rffi.INT, rffi.INT, rffi.UINT], SEM_T)
		_RPY_._sem_unlink = external('sem_unlink', [rffi.CCHARP], rffi.INT)
		_RPY_._sem_wait = external('sem_wait', [SEM_T], rffi.INT)
		_RPY_._sem_trywait = external('sem_trywait', [SEM_T], rffi.INT)
		_RPY_._sem_post = external('sem_post', [SEM_T], rffi.INT)
		_RPY_._sem_getvalue = external('sem_getvalue', [SEM_T, rffi.INTP], rffi.INT)


	def get_function( self, name ):
		for fw in self.wrapped:
			if fw.name == name: return fw

	def get_class( self, name ):
		for w in self.classes:
			if w.__name__ == name: return w

	def object(self, klass):
		n = klass.__name__
		setattr( _RPY_, n, klass )
		rpyinit = eval('lambda : _RPY_.%s()'%n)
		rpyinit.func_name = '_rpyinit_%s' %n
		setattr( _RPY_, '_rpyinit_%s'%n, rpyinit )
		self.classes.append( klass )
		return klass	# must return same classobject because pypy needs to see it

	def stackless(self, func):
		assert not self._stackless		# only one stackless loop allowed
		self._stackless = True
		if not self._threading: self._setup_threading()
		self._threading = True
		fw = _rpy_func_bind( {}, stackless=True )
		fw( func )
		self.wrapped.append( fw )
		_RPY_._stackless_ = func
		return fw.wrapper

	def bind(self, **kw ):					# @decorator
		fw = _rpy_func_bind( kw )
		self.wrapped.append( fw )
		return fw


	def cache(self, mname, refresh=False):		# loads and compiles rpython module for CPython
		if refresh:
			self._gen( mname )
			mod = load( mname, debug=True )
		else:
			try: mod = load( mname, debug=True )
			except:
				self._gen( mname )
				mod = load( mname, debug=True )

		#if hasattr( mod, 'pypy_g_frameworkgc_setup' ):
		#	print('setting up pypy framework gc')
		#	mod.pypy_g_frameworkgc_setup()
		mod.instrument_setup()
		mod.RPython_StartupCode()
		#stackless#mod.pypy_g_slp_entry_point


		rpyinits = {}	# classname : ctypes function
		for n in mod.RPYTHONIC_WRAPPER_FUNCTIONS:
			if n.startswith('pypy_g_'):
				m = n[7:]
				fw = self.get_function( m )
				if m.startswith('_rpyinit_'):
					assert not fw
					klass = m.split('_rpyinit_')[-1]
					rpyinits[ klass ] = mod.RPYTHONIC_WRAPPER_FUNCTIONS[ n ]

				elif fw:
					print( 'replacing python function with ctypes function', fw.name )
					if fw.stackless:
						fw.wrapper.function = mod.RPYTHONIC_WRAPPER_FUNCTIONS[ 'pypy_g_slp_entry_point' ]
					else: fw.wrapper.function = mod.RPYTHONIC_WRAPPER_FUNCTIONS[ n ]

		for klass in self.classes:
			n = klass.__name__
			mpath = klass.__module__.replace('.','_')
			print( 'Shared-Object: %s' %n )
			struct = getattr( mod, 'pypy_%s_%s0' %(mpath,n) )
			#print( struct, struct.__class__.__name__ )
			#assert struct.__class__.__name__ in 'StructType PyCStructType'.split()		# python2.7 ctypes renamed to PyCStructType
			assert n in rpyinits

			setattr( klass, '__getattr__', _rpy_object_getattr )
			setattr( klass, '_rpystruct_', struct )
			setattr( klass, '_rpytype_', ctypes.POINTER(struct) )
			setattr( klass, '_rpyinit_', rpyinits[n] )
			la = lambda s, *args: setattr( s, '_pointer', ctypes.cast(s._rpyinit_(*args),s._rpytype_)  )
			setattr( klass, '__init__', la )		# changes init of class to call generated rpyinit, that returns ctypes pointer

			for f in mod.RPYTHONIC_WRAPPER_FUNCTIONS:
				prefix = 'pypy_g_%s_'%n
				if f.startswith(prefix):
					methname = f[ len(prefix) : ]
					#print '	meth name:', methname
					if methname in dir( klass ):
						#print '	class contains method:', methname
						if not methname.startswith('_'):
							print( 'replaced method with compiled method: %s' %methname )
							setattr( klass, '_rpymethod_%s' %methname, mod.RPYTHONIC_WRAPPER_FUNCTIONS[ f ] )
							lamb = eval( 'lambda _self, *args, **kw: _self._rpymethod_%s(_self._pointer, *args, **kw)' %methname )
							setattr( klass, methname, lamb )
					else:
						print( 'WARN: meth not found in class', n )


		#for n in dir(mod):
		if 0:
			a = getattr(mod,n)
			#if isinstance( a, ctypes.Structure ):
			if hasattr(a,'__class__') and a.__class__.__name__ == 'PyCStructType':
				n = a.__name__
				if n.startswith('pypy___main___'):
					m = n[ len('pypy___main___') : ][ : -1 ]
					w = self.get_class( m )
					if w:
						print( 'found class match', m, w )
						assert m in rpyinits
						setattr( w, '__getattr__', _rpy_object_getattr )
						setattr( w, '_rpystruct_', a )
						setattr( w, '_rpytype_', ctypes.POINTER(a) )

						setattr( w, '_rpyinit_', rpyinits[m] )
						la = lambda s, *args: setattr( s, '_pointer', ctypes.cast(s._rpyinit_(*args),s._rpytype_)  )
						setattr( w, '__init__', la )		# changes init of class to call generated rpyinit, that returns ctypes pointer

						for f in mod.RPYTHONIC_WRAPPER_FUNCTIONS:
							prefix = 'pypy_g_%s_'%m
							if f.startswith(prefix):
								methname = f[ len(prefix) : ]
								print( '	meth name:', methname )
								if methname in dir( w ) and not methname.startswith('_'):
									setattr( w, '_rpymethod_%s' %methname, mod.RPYTHONIC_WRAPPER_FUNCTIONS[ f ] )
									lamb = eval( 'lambda _self, *args, **kw: _self._rpymethod_%s(_self._pointer, *args, **kw)' %methname )
									setattr( w, methname, lamb )

		return mod


	def _gen(self,mname):
		global CTYPES_OUTPUT

		#g = ['_float=.0; _int=0']	# this wont work because pypy is too smart
		g = [									# workaround, declare non-concrete variables
			'from pypy.rlib import streamio',
			's = streamio.fdopen_as_stream(1, "r", 0)',
			'_int = int( s.read(1) )',
			'_float = float( s.read(1) )',
			'_str = str( s.read(2) )',
			'_char = str( s.read(1) )',
			'_bool = bool( _int )',
		]

		for klass in self.classes:
			n = klass.__name__

			#if self._threading and klass is self.Lock:
			#	g.append( '_RPY_._lock_ = _RPY_._new_%s()' %n )
			#	g.append( 'a = _RPY_._lock_' )
			#else:
			g.append( 'a = _RPY_._rpyinit_%s()' %n )	# could do proper init here, and below class() no-args
			g.append( 'print str(a)' )


			for aname in dir( klass ):
				attr = getattr( klass, aname )
				if not aname.startswith('_') and inspect.ismethod(attr):
					spec = inspect.getargspec( attr )
					s = ''
					if spec.args:
						for ai,an in enumerate(spec.args):
							if ai == 0: continue
							arg = type( spec.defaults[ ai-1 ] )
							if arg is int: s += '_int,'
							elif arg is float: s += '_float,'
							elif arg is str: s += '_str,'
							elif arg is ctypes.c_char: s += '_char,'
							elif arg is bool: s += '_bool,'
							else: s += '%s(),' %arg.__name__		# TODO, this is tricky

					g.append( 'b = a.%s( %s )'%(aname,s) )
					g.append( 'print str(b)' )

		for i,fw in enumerate(self.wrapped):
			if fw.name == '__init__': continue
			setattr(_RPY_, fw.name, fw.function)
			s = 'val%s = _RPY_.%s(' %(i,fw.name)		# tricky - part1
			for arg in fw.arguments:	# TODO detect global singleton instances?
				if arg is int: s += '_int,'
				elif arg is float: s += '_float,'
				elif arg is str: s += '_str,'
				elif arg is ctypes.c_char: s += '_char,'
				elif arg is bool: s += '_bool,'
				else: s += '%s(),' %arg.__name__		# TODO, tricky - save instances above?
			s += ')'
			g.append( s )
			g.append( 'print val%s' %i )		# tricky - part2: prevents pypy from inlining

		g.insert(0, 'print "generated ugly declare - this should never be called directly"' )
		#g.append( 'return 1' )
		g = 'def declare_ugly():\n\t' + '\n\t'.join( g )
		print( g )
		exec( g )
		print( '--------compiling rpython-----------' )
		# TODO how to tell inliner not to inline in main?  pypy.translator.backendopt.inline.inlining_heuristic
		# inliner just moves OP_INT_ADD into main...
		secondary_entrypoints = []
		secondary_entrypoints.append( (declare_ugly, []) )

		if self._stackless: entry = _rpy_stackless_entrypoint
		else: entry = lambda x: 1

		headers,sources = translate_rpython( 
			entry, 
			inline=False, 
			stackless=self._stackless, 
			gc=self._gc,
			functions=secondary_entrypoints,
		)
		pypygen = {}
		_paths = []
		for c in sources:
			pypygen[ c.basename ] = c
			_paths.append( c.strpath )
			print( c.strpath )

		_pypyinc = os.path.join(PATH2PYPY,'pypy/translator/c/')
		if _pypyinc not in INCLUDE_DIRS: INCLUDE_DIRS.append( _pypyinc )		# contains src/

		testlib = GCC.compile( 
			mname,
			paths = _paths,
			includes = [ _pypyinc ],
			gc=self._gc,
		)

		pre = os.path.join( 'genctypes', mname )
		mdir = os.path.join( CACHEDIR, pre )
		if not os.path.isdir( mdir ):
			os.makedirs( mdir )
			open( os.path.join(os.path.join(CACHEDIR,'genctypes'),'__init__.py'), 'wb' )
		CTYPES_OUTPUT = os.path.join(pre,'__init__.py')
		LIBS.append( 'lib%s.so' %mname)
		a = C( pypygen['implement.c'].strpath, debug=0 )
		a.save()

		print( g )








